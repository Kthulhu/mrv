<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="section" id="developing-with-mrv">
<span id="development-label"></span><h1>Developing with MRV</h1>
<p>MRV is a framework onto which new programs are easily being built, and it provides many tools to facilitate development and to help producing good software quickly.</p>
<p>Setting up your development environment is the first step, which involves cloning the MRV mainline repository, and assuring that some prerequisites are met.</p>
<p>The second part of this guide explains the naming conventions used in MRV and tells you about the development practices employed to produce it.</p>
<p>At the end of this article, there are tips on how to optimize your code for performance, and how to contribute to the MRV project.</p>
<div class="section" id="development-environment">
<h2>Development Environment</h2>
<p>This paragraph describes the required setup and configuration of your system to develop MRV or projects based on MRV.</p>
<div class="section" id="prerequisites">
<h3>Prerequisites</h3>
<p>The following software packages need to be installed,</p>
<ul class="simple">
<li>Git 1.6.5 or higher</li>
<li>Autodesk Maya 8.5 or higher</li>
<li><em>Testing Framework</em></li>
</ul>
<blockquote>
<ul class="simple">
<li>Nose 0.11 or higher</li>
<li>Coverage ( optional )</li>
</ul>
</blockquote>
<ul class="simple">
<li><em>Documentation Generation</em></li>
</ul>
<blockquote>
<ul class="simple">
<li>Epydoc 3.x</li>
<li>Sphinx 0.62 or higher ( currently Linux and OSX only )</li>
</ul>
</blockquote>
<p>The following installation guide <em>assumes you have already installed git and Autodesk Maya</em> for your platform. For instruction, please see the documentations of the respective software package.</p>
</div>
<div class="section" id="installation">
<h3>Installation</h3>
<p>The basic installation steps are similar in all supported operating systems. Getting MRV to run within a standalone interpreter differs between the platforms.</p>
<p>If a standalone interpreter does not work for you, its absolutely possible to run MRV within the default maya python interpreter, <tt class="docutils literal"><span class="pre">mayapy</span></tt>.</p>
<div class="section" id="install-the-prerequisites">
<span id="install-label"></span><h4>1. Install the Prerequisites</h4>
<p>The instructions assume you are going to run MRV within a standalone interpreter. If you are planning to use mayapy, the installation may be more complicated, but in general all that needs to be done is to put the required package(s) into the 'site-packages' folder of your python installation.</p>
<p>Using easy_install, which comes with the <a class="reference external" href="http://pypi.python.org/pypi/setuptools">python setuptools</a> the installation is as easy as the name suggests:</p>
<pre class="literal-block">
$ easy_install&lt;python_version&gt; nose coverage sphinx epydoc
</pre>
<p>Please note that the version of easy_install is important as you need to install the prerequisites for each python version that is used by the maya version you are going to run:</p>
<ul class="simple">
<li>Maya 8.5 -&gt; Python 2.4</li>
<li>Maya 2008|2009 -&gt; Pyhthon 2.5</li>
<li>Maya 2010 -&gt; Python 2.6</li>
</ul>
<p>The generation of the full documentation currently only works on linux and OSX, partial epydoc documentation works on windows as well. You don't strictly need sphinx and/or epydoc to develop with MRV.</p>
<div class="section" id="mayapy">
<h5>Mayapy</h5>
<p>The only package that you need to install to run the tests is <tt class="docutils literal"><span class="pre">nose</span></tt>. Its recommended to retrieve the package using easy_install for your standalone interpreter and to alter your <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt> to include the <tt class="docutils literal"><span class="pre">site-packages</span></tt> directory of your local python installation.</p>
<p>Alternatively, copy the <tt class="docutils literal"><span class="pre">nose</span></tt> package into <em>&quot;C:\Program Files\Autodesk\Maya&lt;version&gt;\Python\Lib\site-packages&quot;</em> ( windows ), into <em>&quot;/usr/autodesk/maya&lt;version&gt;/lib/python&lt;pyversion&gt;/site-packages&quot;</em> ( Linux ) or into <em>&quot;/Applications/Autodesk/maya&lt;version&gt;/Maya.app/Contents/Frameworks/Python.framework/Versions/&lt;pyversion&gt;/lib/python&lt;pyversion&gt;/site-packages&quot;</em> ( OSX ).</p>
</div>
</div>
<div class="section" id="get-a-or-your-repository-clone">
<span id="repo-clone-label"></span><h4>2. Get A or Your Repository Clone</h4>
<p>Clone the MRV mainline repository from gitorious or github. Either fork your own on www.gitorious.org/mrv or www.github.com/Byron/mrv and clone from your fork, or clone from the mainline repository as shown here.</p>
<p>Execute the following:</p>
<pre class="literal-block">
$ git clone git://gitorious.org/mrv/mainline.git mrv
$ git submodule update --init
</pre>
<p>On linux and OSX, you would have done this in a shell of your choice. On windows, you would have retrieved a shell using the &quot;Git Bash Here&quot; menu entry in your RMB explorer menu when clicking on a parent-folder of your choice.</p>
<div class="section" id="windows">
<h5>Windows</h5>
<p>On Windows, make sure that the MRV repository has at least one folder between itself and the drive letter. Otherwise you are not able to run tests properly due to some issue with nose on windows (apparently).</p>
<ul class="simple">
<li>This is wrong:</li>
</ul>
<blockquote>
<ul class="simple">
<li>c:\mrv\[.git]</li>
</ul>
</blockquote>
<ul class="simple">
<li>This would work:</li>
</ul>
<blockquote>
<ul class="simple">
<li>c:\projects\mrv\[.git]</li>
</ul>
</blockquote>
</div>
</div>
<div class="section" id="run-the-tests">
<h4>3. Run the tests</h4>
<p>By running the tests, you verify that the installation actually succeeded as you are able to run MRV in a standalone interpreter.</p>
<p>In your shell, you should now be able to execute the <tt class="docutils literal"><span class="pre">tmrv</span></tt> command as follows:</p>
<pre class="literal-block">
$ cd mrv
$ # start the tests for the given maya version, 2011 in this case
$ test/bin/tmrv 2011
</pre>
<p>All tests are expected to succeed. Please note that <tt class="docutils literal"><span class="pre">tmrv</span></tt> just executes <tt class="docutils literal"><span class="pre">mrv/bin/mrv</span></tt> and launches nosetest afterwards, hence all parameters supported <tt class="docutils literal"><span class="pre">nosetests</span></tt> in your particular installation will work here as well.</p>
<p>On OSX, the default python installation will not work if you intend to run Maya2010 or later. Please see the <tt class="docutils literal"><span class="pre">Troubleshooting</span></tt> guide for a solution which is essentially using mayapy. This can be achieved using the following command:</p>
<pre class="literal-block">
$ test/bin/tmrv 2011  --mrv-mayapy
</pre>
<p>On <em>windows</em>, in a command prompt, execute:</p>
<pre class="literal-block">
$ cd mrv
$ python test\bin\tmrv 2011 &lt;full/path/to/test/directory&gt;
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">On windows, you can use the same commands presented here if you use a git-bash instead of cmd.exe.</p>
</div>
</div>
<div class="section" id="troubleshooting">
<h4>Troubleshooting</h4>
<p>This paragraph informs about possible issues which have a solution already.</p>
<div class="section" id="osx-and-32bit-64bit-mismatch">
<h5>OSX and 32bit/64bit Mismatch</h5>
<p>Starting with Maya2011, maya is delivered as 64 bit binary. The default interpreter in your path should be 64 bits as well, but if it is not, you have to make some adjustments. Conversely, Maya2010 uses Pyhthon2.6 which is 64 bit on Snow Leopard, whereas Maya was just compiled in 32 bits.</p>
<p>To solve the issue, either install a python interpreter which matches the architecture of your respective maya version, or use mayapy.</p>
</div>
<div class="section" id="still-troubled-use-mayapy">
<h5>Still troubled ? Use mayapy</h5>
<p>If the standalone interpreter just doesn't want to work on your platform or with your particular configuration, you may always use <tt class="docutils literal"><span class="pre">mayapy</span></tt>, which can be found in the <em>&lt;maya_install_directory&gt;/bin</em> folder. It will setup a standalone interpreter which automatically pulls in the packages required for Maya to work.</p>
<p>As a side-effect, <tt class="docutils literal"><span class="pre">nose</span></tt> needs to be installed in mayapy's <em>site-packages</em> directory, as indicated in the <a href="#id1"><span class="problematic" id="id2">:ref:`installation section&lt;install-label&gt;`</span></a>.</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 133); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<p>To force using mayapy, use the <tt class="docutils literal"><span class="pre">--mrv-mayapy</span></tt> flag:</p>
<pre class="literal-block">
$ # start the mayapy python interpreter in interactive mode
$ bin/mrv 2011 --mrv-mayapy

$ # run all tests in mayapy
$ /test/bin/tmrv 2009 --mrv-mayapy
</pre>
</div>
</div>
</div>
</div>
<div class="section" id="mrv-naming-conventions">
<span id="naming-conventions-label"></span><h2>MRV Naming Conventions</h2>
<p>MRV's primary intention regarding its naming conventions is to fit into the ones already setup by the MayaAPI, while trying not to completely neglect the python heritage and PEP8 which comes with it.</p>
<div class="section" id="method-names">
<h3>Method Names</h3>
<p>MRV uses methods named <tt class="docutils literal"><span class="pre">setProperty</span></tt> to set the given property on an instance, and <tt class="docutils literal"><span class="pre">property</span></tt> to retrieve that property. <tt class="docutils literal"><span class="pre">property</span></tt> may take arguments as well to possibly configure the way the property is retrieved.</p>
<p>To indicate non-property values, which are values that have to be generated or produced in some way, the method is prefixed to give a hint on the underlying operation, such as in <tt class="docutils literal"><span class="pre">findValue</span></tt> or <tt class="docutils literal"><span class="pre">createItem</span></tt>.</p>
<p>If the property is a boolean, and if it equals a state of the instance, the method prefix is chosen to be close to 'natural english', i.e. <tt class="docutils literal"><span class="pre">isLocked</span></tt>, or <tt class="docutils literal"><span class="pre">hasCache</span></tt>.</p>
<p>Public methods which are part of the maya related parts of MRV must obey to this convention. Protected methods, that is methods which are not part of the public interface, may be named according to PEP8 as well.</p>
<p>Public MRV methods which do not depend on maya in any way may use PEP8, but it is advised to keep the naming consistent with the one employed by the MayaAPI if the interface is used by the maya dependent parts. For example, even though the types in <tt class="docutils literal"><span class="pre">mrv.interfaces</span></tt> don't depend on Maya, Maya depends on them, so their public methods are camel-cased.</p>
<p>If you derive from a base type which uses PEP8 naming conventions, you must keep that convention alive in the interface methods you add, even if your type is used by the maya related parts of MRV.</p>
</div>
<div class="section" id="variable-names">
<h3>Variable Names</h3>
<p>Within your method or function, great freedom can be exercised regarding the names of variables. Some like camel-cased variableNames, others prefer PEP8 variable_names, and neither one is right or wrong. Choose what seems most appropriate for you, and whatever you like typing more. Within MRV, you might find passages that use a 'MEL' style variable naming, other parts prefer PEP8. In general, MRV will prefer PEP8 over camel-cases as its easier to type, which in turn increases productivity.</p>
</div>
<div class="section" id="method-aliases">
<h3>Method Aliases</h3>
<p>If MRV overrides native MFnFunctionSet methods, the overriding function will use the same name even if it prefixed with 'get' - that prefix is usually dropped in MRV. In that case though, an alias is provided to conform to MRV's naming conventions. As an example, if the method <tt class="docutils literal"><span class="pre">MFnFoo.getBar</span></tt> is overridden with <tt class="docutils literal"><span class="pre">FooNode.getBar</span></tt>, an alias called <tt class="docutils literal"><span class="pre">FooNode.bar</span></tt> would be provided.</p>
<p>If an overridden MFnMethod uses X, no alias is provided for getX. For example, <tt class="docutils literal"><span class="pre">MFnFoo.bar</span></tt> would be overridden with <tt class="docutils literal"><span class="pre">FooNode.bar</span></tt>, but an alias called <tt class="docutils literal"><span class="pre">FooNode.getBar</span></tt> will <em>not</em> be provided.</p>
<p>Commonly used methods with long names, such as <tt class="docutils literal"><span class="pre">MPlug.misConnectedTo</span></tt> have an abbreviation alias in order to speed up typing and increase typing convenience. Abbreviations only use lower-case letters, and use the first character of each of the camel-cased words. The abbreviation in this case is be <tt class="docutils literal"><span class="pre">MPlug.mict</span></tt>.</p>
</div>
</div>
<div class="section" id="calling-mfnmethods">
<h2>Calling MFnMethods</h2>
<p>Return values of overridden MFNMethods return the wrapped type. ( i.e. DagNode.child ). This is the expected behavior as MFnMethods called on wrapped objects should return wrapped objects to stay in the wrapped 'ecosystem'.</p>
<p>At the current time, MFn methods which receive MObjects or MDagPaths will only
allow MObjects or MDagPaths, wrapped nodes must be converted explicitly. At some
point this should change to allow wrapped nodes as well.</p>
<p>If MFnMethods require the <tt class="docutils literal"><span class="pre">MScriptUtil</span></tt> to be used from python, and if it has not been overridden by MRV yet, there is no convenient way to call it.</p>
<p>If the MFnMethod alters the object in question, and if there is no MRV override yet, undo will not be implemented.</p>
<p>Whenever an MRV developer encounters an 'uncallable' method, he is advised to implement the pythonic version of the method directly on the type or base type in question, see the document about <a href="#id3"><span class="problematic" id="id4">:doc:`Extending MRV&lt;extend&gt;`</span></a> for more information.</p>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 190); <em><a href="#id4">backlink</a></em></p>
Unknown interpreted text role &quot;doc&quot;.</div>
</div>
<div class="section" id="development-workflow">
<span id="development-workflow-label"></span><h2>Development Workflow</h2>
<p>MRV's goal as development framework is to enable the programmer to write reliable, maintainable and well-performing code in less time compared to the conventional methods.</p>
<p>MRV natively assures that the code is well-performing, but reliability cannot be assured without proper testing. Maintainability comes with a good design, and clean code.</p>
<p>If one wanted to find a development strategy which fits the previously mentioned goals, one would definitely encounter TDD on the way - <a class="reference external" href="http://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>.</p>
<p>For the sake of brevity, only the most important points will be mentioned here, check the wiki link above for more information.</p>
<p>When developing for python within maya, one generally has the problem that simply 'sourcing' a file is not possible anymore. Instances of your classes which are still floating around somewhere use the code they have been instantiated with, not the new one which you might just have <tt class="docutils literal"><span class="pre">reload</span></tt> 'ed.</p>
<p>This makes it cumbersome and hard to predict whether you are actually seeing your changes or not.</p>
<p>The only way to be 100% sure that your changes are actually kicking in is to restart the python interpreter ( or maya ), and try again. This of course is not feasible if it is done manually as it takes too much time.</p>
<p>Being aware of this issue, MRV has been developed using TestCases from the ground up. This is why it is possible to rerun a single test every ~3.5s in a standalone interpreter ( as a comparison, maya -batch takes ~5.5 seconds to startup ). The whole test suite can be run in just ~7s, and all regression tests in for Maya 8.5 to 2010 take less than two minutes.</p>
<p>This makes it possible to write code in a test-driven manner, running tests is easy and fast.</p>
<p>Please note that the following examples use a linux shell, but the same development style will work on windows as well provided that you exchange the command-line shown here with a cmd prompt compatible one.</p>
<div class="section" id="mrv-tdd">
<h3>MRV TDD</h3>
<p>When implementing a new MRV feature, it is useful to start by getting a clear idea of what the feature should be like, and who will use it, and how it will be used. Then it is wise to conduct a quick manual test to see whether it is generally possible to do - usually the answer is yes, but its good to get an impression on how difficult it is going to be.</p>
<p>The next step is to find a good place for the code, either it is placed into an existing module, or a new one is created. Before writing a line of code though, a first test case is added into an existing test module, or into a new one.</p>
<p>Ideally you have at least two panes available in your editor, one is for the implementation, the other one for the test. For brevity, lets call the implementation <tt class="docutils literal"><span class="pre">lefty</span></tt>, the test <tt class="docutils literal"><span class="pre">righty</span></tt>.</p>
<p>In <tt class="docutils literal"><span class="pre">lefty</span></tt>, sketch out the design required to implement the feature - do you need a class, or several classes, which member functions do they have, are module level functions reasonable, or do you want to use classmethods instead ?</p>
<p>Once the design has been sketched, its about defining the signature of the methods and functions. Go through them one by one in a suitable order and write the documentation for them - use <a class="reference external" href="http://sphinx.pocoo.org/markup/index.html">restructured Text</a>.</p>
<p>Write down what the method is supposed to do, think about the possible input arguments and their types, the return type, as well as possible exceptions.
While writing this, you essentially define the domain within which this method is supposed to work.</p>
<p>Whenever you set a pile for the fence of your domain, switch to <tt class="docutils literal"><span class="pre">righty</span></tt> and note down what the method can do, or what it can't do to assure you don't forget about the individual things that need to be tested:</p>
<pre class="literal-block">
&gt;&gt;&gt; # &lt;feature.py&gt; in lefty
&gt;&gt;&gt; def makeFoo(bar_iterable, big=False):
&gt;&gt;&gt;     &quot;&quot;&quot;Create a new Foo instance which contains the Bar instances
&gt;&gt;&gt;     retrieved from the bar_iterable.
&gt;&gt;&gt;
&gt;&gt;&gt;     :return: ``Foo`` compatible instance. If big was True, it will
&gt;&gt;&gt;         support the ``BigFoo`` interface
&gt;&gt;&gt;     :param bar_iterable: iterable yielding Bar instances. As Foo's
&gt;&gt;&gt;          cannot exist without Bars, an empty iterable is invalid.
&gt;&gt;&gt;     :param big: if True, change the return type from ``Foo`` to ``BigFoo``
&gt;&gt;&gt;     :raise ValueError: if bar_iterable did not yield any Bar instance&quot;&quot;&quot;
&gt;&gt;&gt;          pass # todo implementation

&gt;&gt;&gt; # &lt;test/test_feature.py&gt; in righty
&gt;&gt;&gt; # It has been written while putting down the docs for the method
&gt;&gt;&gt; def test_makeFoo(self):
&gt;&gt;&gt;     # assure it returns Foo instances, BigFoo if the flag is set
&gt;&gt;&gt;
&gt;&gt;&gt;     # which contain the bars we passed in
&gt;&gt;&gt;
&gt;&gt;&gt;     # empty iterables raise
</pre>
<p>Next up is the implementation of the test case - as it knows the interface of the method to test, it can be fully implemented before writing any actual implementation:</p>
<pre class="literal-block">
&gt;&gt;&gt; # assure it returns Foo instances, BigFoo if the flag is set
&gt;&gt;&gt; bars = (Bar(), Bar())
&gt;&gt;&gt; for big in range(2):
&gt;&gt;&gt;             foo = makeFoo(iter(bars), big)
&gt;&gt;&gt;             assert isinstance(foo, Foo)
&gt;&gt;&gt;             if big:
&gt;&gt;&gt;                     assert isinstance(foo, BigFoo)
&gt;&gt;&gt;             # END check rval type
&gt;&gt;&gt;
&gt;&gt;&gt;             # which contain the bars we passed in
&gt;&gt;&gt;             assert foo.bars == bars
&gt;&gt;&gt;
&gt;&gt;&gt;             # empty iterables raise
&gt;&gt;&gt;             self.failUnlessRaises(ValueError, makeFoo, tuple(), big)
&gt;&gt;&gt;     # END for each value of 'big'
</pre>
<p>Now you have a full frame for all the boundary cases that you have documented before. Run the test repeatedly while implementing your actual classes. Once the test succeeds, you can at least be quite confident that your code is actually working.</p>
<p>The full implementation of the example can be found in <tt class="docutils literal"><span class="pre">mrv.test.maya.nt.test_general</span></tt> ( <em>test_makeFoo</em> ).</p>
<p>The case presented here is of course nothing more than a constructed example, in many cases the flow of the development will be much less 'predefined' and more fluid, and it is usually iterative as well. The basic steps are the same though:</p>
<blockquote>
<ol class="arabic simple">
<li>Understand the problem to solve</li>
<li>Design your Interface, Class or Method by sketching it - write documentation to get an even clearer understanding of the problem, as well as the limits within which you will solve it.</li>
</ol>
<blockquote>
<ul class="simple">
<li>Track the sub-tests that you will need while writing the documentation</li>
</ul>
</blockquote>
<ol class="arabic simple" start="3">
<li>Implement the test case(s)</li>
<li>Write your actual implementation.</li>
</ol>
</blockquote>
<p>Of course it is totally valid to switch order, or jump back and forth between the steps - but the list presented here gives a good outline on how MRV is being developed.</p>
</div>
<div class="section" id="running-tests">
<span id="runtestsdoc-label"></span><h3>Running Tests</h3>
<p>In Test-Driven-Development, running the test is a major part of the workflow, which is why this section presents a few commonly used strategies to test efficiently and conveniently.</p>
<p>Nose is the main test driver, it offers pretty much everything you ever wanted and allows to be extended using plugins rather easily - the following presentation shows only some of the vast amount of features available, you can read more on the <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose">official homepage</a>, the examples should work on linux, OSX and windows.</p>
<p>If your working directory is the MRV root directory, the following command will run all tests ( in about ~7s ):</p>
<pre class="literal-block">
$ test/bin/tmrv &lt;mayaversion&gt;
</pre>
<p>Run individual test packages or module by specifying their paths:</p>
<pre class="literal-block">
$ # runs the Path test, as well as all maya related tests of the given maya version
$ test/bin/tmrv &lt;mayaversion&gt; test/test_path.py test/maya
</pre>
<p>Running tests outside of the maya test package will not startup maya, hence it will return much quicker:</p>
<pre class="literal-block">
$ test/bin/tmrv &lt;mayaversion&gt; test/test_enum.py
</pre>
<p>If an exception is raised in the tests, you will see it in the final output, as well as the caught standard output generated when the test case ran. The <tt class="docutils literal"><span class="pre">-d</span></tt> flag resolves traceback symbols to their actual values. In case you want to jump right into the exception when it occurs, specify <tt class="docutils literal"><span class="pre">--pdb</span></tt>. If you just have a failing test and want to inspect the variable values yourself, use <tt class="docutils literal"><span class="pre">--pdb-failure</span></tt>:</p>
<pre class="literal-block">
$ test/bin/tmrv &lt;mayaversion&gt; test/test_fails.py -d
$ test/bin/tmrv &lt;mayaversion&gt; test/test_fails.py --pdb
$ test/bin/tmrv &lt;mayaversion&gt; test/test_fails.py --pdb-failure
</pre>
<p>As nose will by default catch all standard output of your program, it may also suppress messages you print during the first import of your program. To show all of these as they occur, use the <tt class="docutils literal"><span class="pre">-s</span></tt> flag:</p>
<pre class="literal-block">
$ test/bin/tmrv &lt;mayaversion&gt; test/test_startup_issues.py -s
</pre>
<div class="section" id="testing-user-interfaces">
<h4>Testing User Interfaces</h4>
<p>Testing of user interfaces used to be a manual process, which clearly degrades the reliability of software as its user interface will only be tested occasionally in an unrepeatable and possibly incomplete manner.</p>
<p>Using python, it became far easier to automate user interface testing as your interface elements may provide a clear interface to interact with them. Within certain limits - you will most probably not get around testing a few things manually - you  can at least outline the expected functionality and verify the functionality within these bounds.</p>
<p>The tests currently available in the <tt class="docutils literal"><span class="pre">mrv.test.maya.ui</span></tt> package are showing a few windows, the knowing user may also click a few buttons to verify that callbacks work alright. Considering the possibilities, the tests are rather primitive and are assumed to be working if there is no exception - there are <a class="reference external" href="http://gitorious.org/animio">other tools</a> which do much better in that respect.</p>
<p>These tests currently only show that the UI system is not fundamentally broken, and that Callbacks and Signals work - nonetheless the manual nature of them causes them not to be run very often.</p>
<p>The commandline required to run the tests is the following ( all platforms ):</p>
<pre class="literal-block">
$ test/bin/tmrv [maya_version] --mrv-maya [ nose arguments ]
</pre>
<p>In future, this testing system is likely to be improved, also considering that QT offers a <a class="reference external" href="http://qt.nokia.com/doc/4.2/qtestlib-manual.html">test library</a> which can virtualize mouse clicks and keyboard input, in order to fully automate user interface testing.</p>
<p>Other techniques may be used to allow automated tests on default Maya user interfaces, for more information, please see the <a href="#id5"><span class="problematic" id="id6">:ref:`template-project-label`</span></a> section.</p>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 337); <em><a href="#id6">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">For UI tests to work, <tt class="docutils literal"><span class="pre">mayapy</span></tt> needs to be able to import <tt class="docutils literal"><span class="pre">nose</span></tt> to run the actual tests.</p>
</div>
</div>
<div class="section" id="verifying-test-coverage">
<h4>Verifying Test Coverage</h4>
<p>In statically typed languages, one benefits from the great blessing of having a compiler which is able to check types and their compatibility, as well as to verify names at compile time.</p>
<p>Unfortunately, Python will only be able to discover this big class of errors at runtime, which essentially is too late. Test cases help to run your code, but are you sure it is running every line of it ?</p>
<p>Nose comes with an excellent tool which verifies the tests code coverage. As it needs a few options, there is a tmrv flag which configures nose to run all or the specified tests with coverage output:</p>
<pre class="literal-block">
$ test/bin/tmrv &lt;mayaversion&gt; --mrv-coverage
$ firefox coverage/index.html
</pre>
<p>The resulting web page highlights all lines that ran, and shows the ones that did not run, which enables you to adjust your tests to run all the lines.</p>
<p>At the time of writing (<a href="#id22"><span class="problematic" id="id23">|today|</span></a>), MRV had a <a href="#id7"><span class="problematic" id="id8">:download:`test coverage of 90% &lt;download/coverage/index.html&gt;`</span></a>, but of course <a class="reference external" href="http://www.infoq.com/news/2007/05/100_test_coverage">test coverage is not everything</a>.</p>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 354); <em><a href="#id8">backlink</a></em></p>
Unknown interpreted text role &quot;download&quot;.</div>
</div>
<div class="section" id="regression-testing">
<h4>Regression Testing</h4>
<p>As MRV is meant to be useful in all Maya Releases which support python, namely 8.5 till X where X is the latest release, it must be verified that all tests indeed succeed in all available Maya versions, ideally on all platforms.</p>
<p><tt class="docutils literal"><span class="pre">tmrvr</span></tt> greatly facilitates running these tests:</p>
<pre class="literal-block">
$ test/bin/tmrvr
$ test/bin/tmrv [maya version] --mrv-maya test/maya/ui
</pre>
</div>
</div>
<div class="section" id="ipython-and-imrv">
<h3>IPython and IMRV</h3>
<p>During development, it is unlikely that one remembers all methods available on instances of a certain type, sometimes its required to just quickly test or verify something, or to pull up the docs on a basic but rarely used python built-in function. Searching the Web is possible, but using <tt class="docutils literal"><span class="pre">ipython</span></tt> is much more convenient.</p>
<p><tt class="docutils literal"><span class="pre">imrv</span></tt>, one of MRVs <a href="#id9"><span class="problematic" id="id10">:doc:`tools`</span></a>,  essentially is an ipython shell which has been setup to load a specialized version of the MRV runtime to provide you with a fully initialized MRV runtime environment:</p>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 369); <em><a href="#id10">backlink</a></em></p>
Unknown interpreted text role &quot;doc&quot;.</div>
<pre class="literal-block">
$ bin/imrv
</pre>
<pre class="literal-block">
&gt;&gt;&gt; p = Node(&quot;persp&quot;)
Transform(&quot;|persp&quot;)

List all available methods on the perspective transform:
&gt;&gt;&gt; p.&lt;tab-key&gt;

Show the doc-string of a method:
&gt;&gt;&gt; p.name?

Jump into the debugger next time an exception occurs:
&gt;&gt;&gt; pdb

Disable the debugger
&gt;&gt;&gt; pdb
</pre>
</div>
<div class="section" id="avoiding-trouble-a-word-about-reference-counts">
<h3>Avoiding Trouble - A Word about Reference Counts</h3>
<p>As MRV nearly exclusively uses the API to do work, it also allows you to use the underlying API types, MObject and MDagPath, directly.</p>
<p>If used correctly, the benefit is performance and ease of use, but in the worst case, maya will crash - this happens more easily when using the Maya API than when using MEL for example.</p>
<p>To understand the source of the issue, one has to understand what an MObject is: MObjects are containers with a reference count, a type and a pointer to the actual data. This in fact is very similar to the <tt class="docutils literal"><span class="pre">object</span></tt> base type in python.</p>
<p>If you see an MObject in python, such as in the following snippet ...</p>
<pre class="literal-block">
&gt;&gt;&gt; p = Node(&quot;persp&quot;)
&gt;&gt;&gt; po = p.object()
&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x36a2ee0&gt; &gt;
</pre>
<p>... what you actually see is a proxy object which serves as a python handle to the actual C++ MObject. The reference count of that proxy object is 1, as it is stored in only one named variable, <tt class="docutils literal"><span class="pre">po</span></tt>. The caveat here is that this does not affect the reference count of the underlying MObject at all - its reference count is the same as it was before. The only one who actually holds a reference to it is Maya, and it is allowed to drop it at any time, or copy its memory to a different location. If that would happen, any access to <tt class="docutils literal"><span class="pre">p</span></tt> or <tt class="docutils literal"><span class="pre">po</span></tt> may cause a crash or destabilize Maya to cause a crash later, which is even worse.</p>
<p>The only way to forcibly increment the reference count is by copying the MObject explicitly:</p>
<pre class="literal-block">
       &gt;&gt;&gt; poc = api.MObject(po)
       &gt;&gt;&gt; po, poc
       (&lt;maya.OpenMaya.MObject; proxy of C++ MObject instance at _f0d5050500000000_p_MObject&gt;,
&lt;maya.OpenMaya.MObjectPtr; proxy of C++ MObject instance at _1008460200000000_p_MObject&gt;)
</pre>
<p>This invoked the C++ copy constructor, and incremented the reference count on the MObject. Copying MObjects might come at additional costs though in case the MObject encapsulates data.</p>
<p>When adding attributes with the bare python Maya API, this situation can easily occur:</p>
<pre class="literal-block">
&gt;&gt;&gt; p.addAttribute(api.MFnTypedAttribute().create(&quot;sa&quot;, &quot;stringarray&quot;, api.MFnData.kStringArray, api.MFnStringArrayData().create())
</pre>
<p>In this example, we created two temporary function sets, <tt class="docutils literal"><span class="pre">MFnTypedAttribute</span></tt> and <tt class="docutils literal"><span class="pre">MFnStringArrayData</span></tt>. The <tt class="docutils literal"><span class="pre">create</span></tt> methods of the respective sets return newly created MObjects - the only one who keeps a reference is the actual function set. Two bad things happened in the example:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">MFnStringArrayData</span></tt> returned an MObject encapsulating an empty string array, then it goes out of scope, and decrements its reference count on the returned MObject during its destruction sequence. The MObject has no one referencing it anymore, so it will destroy itself and its data. Python still has a handle onto the memory location that once kept the MObject, and it is passed to <tt class="docutils literal"><span class="pre">MFnTypedAttribute.create</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">MFnTypedAttribute.create</span></tt> produces a new attribute <tt class="docutils literal"><span class="pre">MObject</span></tt> with (possibly) invalid default data, returns it and destroys itself as it goes out of scope. Again, the reference count of the newly created Attribute MObject decrements to 0, which destroys the Attribute and its data. The python handle you got will be passed to the <tt class="docutils literal"><span class="pre">p.addAttribute</span></tt> method, which tries to create an attribute from deleted data.</li>
</ol>
<p>If you try that line, you will see that it apparently works, but its not guaranteed to do so, nor will you be able to tell whether the caused memory corruption will crash Maya at a later point.</p>
<p>The alternative to the line above is to use the Attribute wrappers that MRV provides:</p>
<pre class="literal-block">
&gt;&gt;&gt; p.addAttribute(TypedAttribute.create(&quot;sa&quot;, &quot;stringarray&quot;, Data.Type.kStringArray, StringArrayData.create()))
</pre>
<p>In the version above, both create methods implicitly copy the returned MObject, which forcibly increments its reference count. Once the underlying MFnFunctionSet goes out of scope, it will decrement the MObject's reference counts to 1, keeping it alive and healthy.</p>
<p>Generally, when dealing with MObjects directly, keep the reference count in mind especially in case of MObjects that have just been created.</p>
<p>In c++, this is not a problem as MObjects are copied automatically when being assigned to a variable for instance or when being passed into functions ( most of the time ). If you have a proper compiler though, the above line would be invalid as well as you return temporary objects and pass them in as reference.</p>
<p>In python, there is no compiler who would be able to check for this.</p>
</div>
</div>
<div class="section" id="contributing">
<span id="contribute-label"></span><h2>Contributing</h2>
<p>MRV is an open source project based on the work of just one person ( for now ), which doesn't only mean that this person must be slightly crazy, but also that MRV was written from just one perspective. There is a <a class="reference external" href="http://vimeo.com/10611158">gource video</a> which illustrates that ... pretty lonely situation.</p>
<p>Many convenience methods, for instance the ones in <tt class="docutils literal"><span class="pre">mrv.maya.nt.geometry</span></tt> have been written because there was a specific need for it. Many areas that would need additional implementations have not seen any attention yet.</p>
<p>The solution to this problem is to make MRV accessible by providing a solid documentation, and to actually make contribution easy. With traditional SCM's, this is not the case as you may not do anything with the repository unless special permissions are granted.</p>
<p>With <a class="reference external" href="http://git-scm.com">git</a> though, or any distributed version control system for that matter, this is a problem of the past as your clone of the repository contains all information you need to , theoretically, found your very own version of the software. Make your own branches, apply your own patches, commit whenever you want, and rebase your changes onto the latest version of the mainline repository that you originally cloned from.</p>
<p>With contributions, the scene you have seen in the first video, <a class="reference external" href="http://vimeo.com/10617731">might soon look more like this</a>.</p>
<div class="section" id="using-git">
<h3>Using Git</h3>
<p>Once you have cloned your initial copy from the mainline repository ( see <a href="#id11"><span class="problematic" id="id12">:ref:`repo-clone-label`</span></a> ), you stay up-to-date by fetching ( <tt class="docutils literal"><span class="pre">git</span> <span class="pre">fetch</span></tt> ) the latest changes from mainline and by merging them into your master branch ( <tt class="docutils literal"><span class="pre">git</span> <span class="pre">merge</span></tt> ).</p>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 455); <em><a href="#id12">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<p>In order to contribute though, the by far easiest workflow is to create your own MRV fork on either <a class="reference external" href="http://gitorious.org/mrv">www.gitorious.com</a> or on <a class="reference external" href="http://www.github.com/Byron/mrv">www.github.com</a>.</p>
<p>When creating own features or patches, you just put them into a separate branch ( using <tt class="docutils literal"><span class="pre">git</span> <span class="pre">co</span> <span class="pre">-b</span> <span class="pre">myfeature</span></tt> ), commit your changes using <tt class="docutils literal"><span class="pre">git</span> <span class="pre">commit</span> <span class="pre">...</span></tt> and finally push everything into your public repository ( <tt class="docutils literal"><span class="pre">git</span> <span class="pre">push</span> <span class="pre">...</span></tt> ) and create a merge request. Once it has been merged into the mainline repository, your change automatically makes it into the next MRV release and the mainline repository.</p>
<p>The workflow presented here is only a rough introduction to the multitude of possible git workflows, and more concrete examples will be added as the need arises.</p>
</div>
</div>
<div class="section" id="making-releases">
<h2>Making Releases</h2>
<p>Although there is a build and release sysetm, at the time of writing ( <a href="#id24"><span class="problematic" id="id25">|today|</span></a> ), it was not used to create the release you have. It will be revised and documented for 1.0.0.</p>
<div class="section" id="building-docs">
<h3>Building Docs</h3>
<p>Currently, building of the full documentation is only supported on linux and on OSX provided that sphinx and epydoc have been installed in your python 2.5 interpreter. The preference for python 2.5 is currently hard-coded into the <tt class="docutils literal"><span class="pre">mrv/docs/sphinx_build</span></tt> script, but there is no reason why it wouldn't work in other python versions if the prerequisites are met.</p>
<p>If that is the case, the following line will build the docs you are currently reading, in the version you have checked out locally:</p>
<pre class="literal-block">
$ cd doc
$ make html
$ # to redo existing docs from scratch
$ make clean html
</pre>
<p>The built documentation can be found in <tt class="docutils literal"><span class="pre">mrv/doc/build/html</span></tt>.</p>
<div class="section" id="id13">
<h4>Windows</h4>
<p>On windows, you may create the epydoc version only, which is rather readable documentation from the source code only, which unfortunately cannot be searched as is the case with the Sphinx documentation.</p>
<p>To do that, execute <tt class="docutils literal"><span class="pre">epydoc.bat</span></tt>, which should work if epydoc has been installed for the python interpreter located in your path:</p>
<pre class="literal-block">
$ cd doc
$ epydoc.bat
</pre>
</div>
</div>
</div>
<div class="section" id="integrating-mrv-into-production-pipelines">
<span id="pipeline-integration-label"></span><h2>Integrating MRV into Production-Pipelines</h2>
<p>MRV sole purpose of existence originally was to serve as foundation of a Maya based 3D production pipeline, details about that can be read in a <a href="#id14"><span class="problematic" id="id15">:doc:`designated article &lt;history&gt;`</span></a>.</p>
<div class="system-message" id="id14">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 497); <em><a href="#id15">backlink</a></em></p>
Unknown interpreted text role &quot;doc&quot;.</div>
<p>Nowadays, and after many improvements, it should be even more useful when applied in the context of pipelines. MRV doesn't weigh much, neither in memory, nor on the CPU, is very well documented and <a href="#id16"><span class="problematic" id="id17">:download:`very well tested &lt;download/coverage/index.html&gt;`</span></a>.</p>
<div class="system-message" id="id16">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 499); <em><a href="#id17">backlink</a></em></p>
Unknown interpreted text role &quot;download&quot;.</div>
<p>Besides that, you are able to <a href="#id18"><span class="problematic" id="id19">:doc:`extend &lt;extend&gt;`</span></a> it to suit your needs, and <a href="#id20"><span class="problematic" id="id21">:doc:`configure &lt;conf&gt;`</span></a> it to suit your needs even better.</p>
<div class="system-message" id="id18">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 501); <em><a href="#id19">backlink</a></em></p>
Unknown interpreted text role &quot;doc&quot;.</div>
<div class="system-message" id="id20">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 501); <em><a href="#id21">backlink</a></em></p>
Unknown interpreted text role &quot;doc&quot;.</div>
<p>Finally, if - after a thorough study of the documentation - there are any questions or doubts left that would prevent its use, I will be glad to help personally.</p>
</div>
<div class="section" id="performance-and-memory-considerations">
<span id="performance-docs-label"></span><h2>Performance and Memory Considerations</h2>
<p>MRV has been created with performance in mind. Core code as gone through several iteration in order to be as fast as it can possibly be within python. This is beneficial to the developer as he can be sure that conveniently written code will run at a high pace.
Usually this kind of code is the most readable and the most maintainable which is why it is preferred. Nonetheless there are situations when performance outweighs code maintainability. This section explains what to look out for and how to improve the performance of your programs.</p>
<p>The respective tips are listed in the order of simplicity and effect, hence simpler and more effective ways to enhance performance come first.</p>
<div class="section" id="iterators">
<h3>Iterators</h3>
<p>When operating in large scenes, its important to limit the amount of nodes that are returned by iterators. The fastest way to do this is to use an MFn.kType pre-filter to limit the yielded Nodes to certain types. As the pre-filtering will happen in C++, it will be very fast:</p>
<pre class="literal-block">
&gt;&gt;&gt; iterDagNodes(api.MFn.kTransform, api.MFn.kShape)            # Fast !
&gt;&gt;&gt; iterDagNodes(predicate=lambda n: isinstance(n, (Transform, Shape))) # slow and wasteful
</pre>
</div>
<div class="section" id="undo">
<h3>Undo</h3>
<p>Turn off the undo queue completely by setting the MRV_UNDO_ENABLED=0 in your environment. This will reduce overhead by at least 10% and increase the performance of many core methods. As a positive side-effect, you have more memory at runtime as the undoqueue will not store the history of operations.</p>
<p>Turning off the undo queue is feasible if you run in maya batch mode and a very easy way to speed up programs.</p>
</div>
<div class="section" id="single-vs-multi">
<h3>Single vs. Multi</h3>
<p>Many programs operate on multiple objects of the same type, as a lot of work needs to be done. Interestingly, many API's seem to embrace the 'single object operation'  paradigm which means that you have to call a single method on all objects individually.</p>
<p>Considering that some boilerplate is involved with each call, which may even weigh more than the actual operation you intend to apply, it obvious that methods that operate on multiple objects at the same time are preferable in many cases.</p>
<p>The Maya API actually does mainly well here, and even though you will find many single object operations, there are many multi-object operations as well.</p>
<p>This implies that it might be worth accumulating the objects you want to work on before sending it to a multi method, which will ideally process the bunch within c++. This costs memory, but will be faster, but memory &lt;-&gt; performance tradeoffs are very common in general.</p>
<p>There are times when you may use iterators instead of lists, they combine the benefits of passing in multiple objects ( at a slight overhead ) without notable memory consumption.</p>
<p>A method worth noting at this point is <tt class="docutils literal"><span class="pre">MPlug.mconnectMultiToMulti</span></tt>, which connects multiple source to multiple destination plugs. It also adds the benefit that it will more efficiently deal with the undo queue, effectively boosting the performance by factor 8 to 14.</p>
</div>
<div class="section" id="convenience-methods">
<h3>Convenience Methods</h3>
<p>Use specialized methods instead of generic ones. Generic methods that accept different types of inputs have to figure out what these types are in order to handle them correctly, each time you call. This is very wasteful especially if your input types do not change in that 20k iteration loop of yours.</p>
<p>That kind of code will perform better if the specialized version of the method is used instead - it only takes a specific input type and comes right to the point.</p>
<p>An example for this would be the overridden <tt class="docutils literal"><span class="pre">__getitem__</span></tt> method of the patched <tt class="docutils literal"><span class="pre">MPlug</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; names = (&quot;persp&quot;, &quot;top&quot;, &quot;time.output&quot;)
&gt;&gt;&gt; sl = api.MSelectionList.mfromList(names)    # slow(er)
&gt;&gt;&gt; sl = api.MSelectionList.mfromStrings(names) # better
</pre>
</div>
<div class="section" id="findplug-vs-node-plug">
<h3>findPlug vs. node.plug</h3>
<p>In fact, using the <tt class="docutils literal"><span class="pre">node.plug</span></tt> convention is a convenience method as well. Internally some processing is needed figure out that you actually want a plug. A more direct way to retrieve plugs is by using the <tt class="docutils literal"><span class="pre">findPlug('plug')</span></tt> method which boost plug lookup performance by quite exactly 7%:</p>
<pre class="literal-block">
&gt;&gt;&gt; for node in iterDagNodes(api.MFn.kTransform):
&gt;&gt;&gt;     node.findPlug('tx')  # 7% faster than ...
&gt;&gt;&gt;     node.tx              # ... this
</pre>
</div>
<div class="section" id="api-calling-convention">
<h3>_api_ calling convention</h3>
<p>What happens whenever you call a method on a wrapped node is the following:</p>
<pre class="literal-block">
&gt;&gt;&gt; node.findPlug('plugname')
&gt;&gt;&gt; # this is equivalent to ...
&gt;&gt;&gt; mfninst = api.MFnDependencyNode(node.getMObject())
&gt;&gt;&gt; mfninst.findPlug('plugname')
</pre>
<p>As you see, you get a temporary function set which gets wrapped around the MObject or MDagPath associated with your node. This is costly as it involves the instantiation of a function set with an API object as well as an API function call. This will happen each time you call the function, even though it would be possible and better to reuse an existing function set.</p>
<dl class="docutils">
<dt>The <tt class="docutils literal"><span class="pre">_api_</span></tt> calling convention does two things.</dt>
<dd><ul class="first last simple">
<li>For patched API types, like MPlug, you receive the original, unpatched instance method.</li>
<li>For Node types, _api_ will return a method which reuses its initialized function set. This will cache the function set, the associated api object as well as the function object itself directly on your node.</li>
</ul>
</dd>
</dl>
<p>To illustrate the _api_ convention on Node types, have a look at this example:</p>
<pre class="literal-block">
&gt;&gt;&gt; for i in xrange(10000):
&gt;&gt;&gt;     perspShape.focalLength()               # much overhead for every call
&gt;&gt;&gt;     topShape._api_focalLength()            # very fast after first call
</pre>
<p>Its good to know about the _api_convention, but it clearly does <em>not</em> mean that you should preventively make all calls using it. This is because the performance gain shows up after the first call only, and only on that specific node. First the cache is built, and used in subsequent calls. In practice, it is unlikely that you are going to repeatetly call the same function on the same node in a tight loop.</p>
<p>Also its worth considering that the cache consumes additional memory, an MFn function set is instantiated and cached for each _api_ call on a Node.</p>
<p>Last but not least, its worth noting that maya controls the lifetime of your API Objects, hence these should not be cached. The _api_ cache usually is very short-lived though and should not make trouble, but it stays a cached MObject within a cached function of the corresponding MFnFunctionSet.</p>
<p>If you find yourself using _api_ method calls all the time, you might consider using the respective function set directly:</p>
<pre class="literal-block">
&gt;&gt;&gt; mfncamera = api.MFnCamera(topShape.getMObject())
&gt;&gt;&gt; for i in xrange(10000):
&gt;&gt;&gt;     mfncamera.focalLength()
&gt;&gt;&gt;     # ... make additional calls at no additional overhead.
</pre>
</div>
<div class="section" id="python-method-caching">
<h3>Python Method Caching</h3>
<p>Generally within python, each attribute access costs time, time that tends to matter in tight loops. You can gain a lot of performance by caching the methods and attributes you have to use in local variables. The previous example could be rewritten like this, maximizing the examples performance:</p>
<pre class="literal-block">
&gt;&gt;&gt; mfncamera = api.MFnCamera(topShape.getMObject())
&gt;&gt;&gt; getFocalLength = mfncamera.focalLength
&gt;&gt;&gt; for i in xrange(10000):
&gt;&gt;&gt;     getFocalLength()                        # as fast as it gets
</pre>
</div>
<div class="section" id="node-wrapping">
<h3>Node-Wrapping</h3>
<p>MRV is very aware of the fact that the added convenience comes at a cost. Where programming convenience and programmer's efficiency is improved, its likely that the runtime of the resulting programs is much less than optimal.</p>
<p>Here its important to make a tradeoff by keeping the code maintainable and readable in most spots, and to optimize it only where it matters.</p>
<p>The wrapping of Nodes takes a considerable amount of time. On a 2 Ghz dual core machine you will get no more than 80k wrapped nodes per second. Turning the wrapping off and going bare API is supported by all methods which automatically wrap nodes, the kwarg is always named <tt class="docutils literal"><span class="pre">asNode</span></tt> which should be set to False in order to get bare MObjects or MDagPaths. This implies that you have to use MFn function sets explicitly:</p>
<pre class="literal-block">
&gt;&gt;&gt; mfndag = api.MFnDagNode()
&gt;&gt;&gt; for mdagpath in iterDagNodes(api.MFn.kTransform, asNode=False):             # uses pre-filter as well
&gt;&gt;&gt;     mfndag.setObject(mdagpath)              # initialize the function set ...
&gt;&gt;&gt;     mfndag.findPlug('translate')    # ... and use it
</pre>
<p>Combining this example with the Python Method Caching, you can maximize the performance of the given example by writing:</p>
<pre class="literal-block">
&gt;&gt;&gt; mfndag = api.MFnDagNode()
&gt;&gt;&gt; setObject = mfndag.setObject
&gt;&gt;&gt; findPlug = mfndag.findPlug
&gt;&gt;&gt; for mdagpath in iterDagNodes(api.MFn.kTransform, asNode=False):             # uses pre-filter as well
&gt;&gt;&gt;     setObject(mdagpath)
&gt;&gt;&gt;     findPlug('translate')
</pre>
<p>The only way to make the previous example even faster is to use the dag node iterator directly with cached methods. This is usually not worth the effort though and will add even more boilerplate code which at some point might just not be worth the maintenance effort anymore.</p>
</div>
</div>
</div>
<div class="section" id="the-template-project">
<span id="template-project-label"></span><h1>The Template Project</h1>
<p>As MRV calls itself a 'Development Framework', it must be simple to create new tools based upon it. The template project gives you a kick-start to do exactly that.</p>
<p>At this stage, the template project itself is still to be created, however, there is a demo project from which it will be derived one day - its called <a class="reference external" href="http://gitorious.org/animio">AnimIO</a>  by Martin Freitag, and allows to export and import animation of nodes.</p>
<p>AnimIO was initially created as MEL script, which makes it especially interesting to see it re-implemented in python, using an Object-Based design and TDD.</p>
<p>The interested reader may have a look at its code. After cloning the repository at <a class="reference external" href="http://gitorious.org/animio">http://gitorious.org/animio</a> ( <tt class="docutils literal"><span class="pre">git</span> <span class="pre">clone</span></tt> ), it is required to recursively initialize the submodules ( <tt class="docutils literal"><span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">update</span> <span class="pre">--init</span> <span class="pre">--recursive</span></tt> ). Now you would be ready to run the tests. To sum it up:</p>
<pre class="literal-block">
$ git clone git://gitorious.org/~byron/animio/byrons-sideline.git animio
$ cd animio
$ git submodule update --init --recursive

$ # Test the library
$ test/bin/runtests [maya version]

$ # Test the performance
$ test/bin/runtests [maya version] test/performance

$ # Test the user interface
$ test/bin/runtestsUI &lt;path/to/maya/bin/maya&gt; test/ui
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The tests of animio will run on all platforms provided that MRV is able to run its tests as well. Effectively, <tt class="docutils literal"><span class="pre">animio</span></tt> uses the same test setup as MRV does.</p>
</div>
</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id22">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 354); <em><a href="#id23">backlink</a></em></p>
Undefined substitution referenced: &quot;today&quot;.</div>
<div class="system-message" id="id24">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">develop.rst</tt>, line 467); <em><a href="#id25">backlink</a></em></p>
Undefined substitution referenced: &quot;today&quot;.</div>
</div>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Comparison to PyMel</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="comparison-to-pymel">
<h1 class="title">Comparison to PyMel</h1>

<p>MRV is not the first attempt to make the use of Python within Maya more convenient. PyMel is an excellent feature packed Framework which is, as the name suggests,  more closely affiliated to MEL than to the Maya API, but which allows you to  access the latter one as well.</p>
<p>Wherever applicable, tables have been used. Otherwise a numbered list is provided which allows to match the respective list items one on one. If list items are  presented in an unnumbered fashion, they indicate a feature which is exclusive to the respective framework or cannot be compared because its too different after all.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The following comparison was created solely based on a single person's judgment, a person which also happens to be the author of MRV. This is why the comparison may be biased towards MRV, miss important features of PyMel or may even be wrong in parts due to an insufficient insight into the PyMel project. The author does not intent to postulate any outrageously incorrect statements, and will be glad to make adjustments if necessary.</p>
</div>
<div class="section" id="ideology">
<h1>Ideology</h1>
<p>TODO: This section needs to be improved, and clarified</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first last arabic simple">
<li>PyMEL builds on the cmds module and allows access to compatible MayaAPI functions as well as respective MEL methods which can be accessed in an object oriented manner.</li>
<li>PyMEL uses MEL semantics.</li>
<li>PyMEL is as convenient and easy-to-use as possible, hiding details about the MayaAPI even if it is used. Direct operation of the MayaAPI is not intended.</li>
<li>Smart methods which take multiple of input types make its use easier and more intuitive.</li>
<li>Type-Handling should be convenient</li>
</ol>
</dd>
<dt><strong>MRV</strong></dt>
<dd><ol class="first last arabic simple">
<li>MRV builds on the MayaAPI and allows access to compatible MFn methods. The cmds module is not handled at all.</li>
<li>MRV uses MayaAPI semantics.</li>
<li>MRV wants to make using the MayaAPI more productive, trying to keep its own impact on performance as low as possible. It is possible and  valid to operate on the native MayaAPI if beneficial for performance.</li>
<li>Specialized methods take very specific input types. There are some general functions which support multiple input types to ease interactive use.</li>
<li>Type-Handling should be explicit.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="features">
<h1>Features</h1>
<div class="section" id="supported-maya-versions">
<h2>Supported Maya Versions</h2>
<p>PyMel:</p>
<ol class="arabic simple">
<li>2008 to 2011</li>
</ol>
<ul class="simple">
<li>Bundled with Maya 2011</li>
</ul>
<p>MRV:</p>
<ol class="arabic simple">
<li>8.5 to 2011</li>
</ol>
</div>
<div class="section" id="database">
<h2>Database</h2>
<p>Both frameworks organize maya's Nodetypes hierarchically and attach information about compatible MFnFunctionSets to them. This information is retrieved  automatically, but is stored in a cache to speed up loading and to allow manual edits.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first arabic simple">
<li>Stored in one compressed file per maya release, which contains multiple pickled files</li>
<li>Database file is fully () decompressed at startup, not necessarily using all information.</li>
<li><strong>Stored Information</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Node Type Hierarchy</li>
<li>MFnFunctionSet to Nodetype Association</li>
<li><strong>Meta Data</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Method Aliases</li>
<li>Method Visibility <a class="footnote-reference" href="#mv" id="id1">[1]</a></li>
<li>Return Value Conversions</li>
</ol>
<ul class="simple">
<li>Choose between MEL or API Methods (, rephrase maybe)</li>
</ul>
</blockquote>
<ul class="simple">
<li>API Docs</li>
<li>MEL Docs</li>
<li>C++ Enumerations</li>
<li>MFnMethod Signatures</li>
</ul>
</blockquote>
<ol class="arabic simple" start="4">
<li><strong>Database Editing</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li>Edit many aspects of the database using a custom tool</li>
<li>edits by hand are not supported</li>
</ol>
</blockquote>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first arabic">
<li><dl class="first docutils">
<dt>Stored in multiple <a href="#id2"><span class="problematic" id="id3">:ref:`human readable text files &lt;database-label&gt;`</span></a>.</dt>
<dd><div class="first system-message" id="id2">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">compare.rst</tt>, line 78); <em><a href="#id3">backlink</a></em></p>
<p>Unknown interpreted text role &quot;ref&quot;.</p>
</div>
<p class="last">Additional Information is taken directly from devkit headers located in your
maya installation directory.</p>
</dd>
</dl>
</li>
<li><p class="first">Two files loaded at startup, all others are loaded on demand.</p>
</li>
<li><p class="first"><strong>Stored Information</strong></p>
</li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Node Type Hierarchy</li>
<li>MFnFunctionSet to Nodetype Association</li>
<li><strong>Meta Data</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Method Aliases</li>
<li>Method Visibility</li>
<li>Return Value Conversions</li>
</ol>
</blockquote>
</blockquote>
<ol class="arabic simple" start="4">
<li><strong>Database Editing</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li>There is no custom tool to edit the database files</li>
<li>Database files are edited by hand in a text editor.</li>
</ol>
</blockquote>
</dd>
</dl>
</div>
<div class="section" id="node-types">
<h2>Node Types</h2>
<p>Both frameworks use their node type hierarchy information to pre-generate all default maya node types and place them in a python module.</p>
<p>Node instances allow access to related methods, either hand-implemented or as  generated from database information.</p>
<p>Access to a Node instances attributes is supported as well, making code like  <tt class="docutils literal"><span class="pre">node.attributename</span></tt> possible.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first arabic simple">
<li><strong>Basic Node Type: ``PyNode``</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Create from: StringNames, MObject, MDagPath, MObjectHandle</li>
<li>PyNodes are (Pseudo)``unicode``-Strings, supporting string methods</li>
<li>All PyNode types are located in the <tt class="docutils literal"><span class="pre">pymel.core.nodetypes</span></tt> module</li>
<li>MayaAPI objects are an implementation detail, and are internally accessed through the PyNode's <tt class="docutils literal"><span class="pre">.__api*__</span></tt> methods and properties, where applicable. Keeps the most appropriate API Object and an initialized function set as well as an MObjectHandle at all times.</li>
<li>A PyNode type is provided for any type available in maya, including plugin types. As plugins load and unload, respective types are added and removed.</li>
<li>Docstrings provide additional information, these are retrieved from the respective MEL command docs if no hand-written doc string exists</li>
<li>The string name of DagNodes is the node's partial name, the shortest unique name.</li>
<li>PyNodes can be used in PyMel provided versions of MEL commands natively.</li>
</ol>
</blockquote>
<ol class="arabic simple" start="2">
<li><strong>Methods</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Attributes hide MFnMethods</li>
<li>MFnMethods are available by only one name which may be aliased, possibly making the original name unavailable. <a class="footnote-reference" href="#mapymel" id="id4">[3]</a></li>
<li>MFnMethods return PyNodes where applicable</li>
<li>MFnMethods originally taking MObjects or MDagPaths also take PyNodes, handling the type conversion internally. The type handling is automated.</li>
<li>MFnMethods normally support undo if a 'setter' method has a corresponding 'getter' method. This functionality is automated.</li>
<li>MFnMethods that would require referenced parameter types which would receive the output of the method are called without them. The output parameters are returned instead <a class="footnote-reference" href="#moppymel" id="id5">[2]</a>. MScriptUtil is never used.</li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>If there are several overloaded signatures, one of them is choosen using the database editing tool</li>
</ol>
</blockquote>
<ol class="arabic simple" start="7">
<li>Docstrings correspond to the respective MFnMethod's documentation, the documentation of the underlying MEL command, or hand-written documentation if the method was implemented by hand.</li>
<li>Methods follow the <tt class="docutils literal"><span class="pre">getX</span></tt> and <tt class="docutils literal"><span class="pre">setX</span></tt> conventions. MFnMethods are not altered to fit this convention, but may be renamed to be more intuitive.</li>
<li>All MFnMethods are attached to the node type when the type is created</li>
</ol>
</blockquote>
<ol class="arabic simple" start="3">
<li><strong>Plugs/Attributes</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">node.plugname</span></tt> returns an <tt class="docutils literal"><span class="pre">Attribute</span></tt> instance, a custom PyMel type.</li>
<li>Attributes can be accessed by their short and long attribute name.</li>
<li>Attributes will be tried first when looking up name, methods are looked up afterwards. This happens on every access</li>
<li>There is no differentiation between Plugs and Attributes, MEL semantics are used.</li>
<li><strong>Data Access</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Access primitive numeric data types and strings.</li>
<li>Full undo is implemented for all modifying methods.</li>
</ol>
</blockquote>
</blockquote>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first arabic simple">
<li><strong>Basic Node Type: ``Node``</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Create from: StringNames, MObject, MDagPath</li>
</ol>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">NodeFromObj</span></tt> creates Node instances from API objects only - used internally for performance.</li>
<li><tt class="docutils literal"><span class="pre">NodeFromStr</span></tt> creates Node instances from strings only</li>
</ul>
</blockquote>
<ol class="arabic simple" start="2">
<li>Nodes are <tt class="docutils literal"><span class="pre">object</span></tt> s</li>
<li>All Node types are located in the <tt class="docutils literal"><span class="pre">mrv.maya.nt</span></tt> package</li>
<li>MayaAPI objects can be retrieved using the <tt class="docutils literal"><span class="pre">.object()</span></tt> and <tt class="docutils literal"><span class="pre">.dagPath()</span></tt> methods, where applicable. The respective MObject and MDagPath instances are permanently stored on the Node. DagNodes store the API object which was used to create them and retrieve their MObject representation on demand.</li>
<li>A Node type is provided for any type available in maya, including plugin types. As plugins load and unload, respective node types are added and removed.</li>
<li>Docstrings are handwritten on basic Node types, and do not exist on auto-generated ones.</li>
<li>The string name of DagNodes is the full absolute path name.</li>
<li>Nodes require explicit conversion to string before being passed to maya.cmds.</li>
</ol>
</blockquote>
<ol class="arabic simple" start="2">
<li><strong>Methods</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>MFnMethods hide Plugs</li>
<li>MFnMethods are available by their original name, but may have an alias to make it available under a more intuitive name.</li>
<li>MFnMethods return Nodes where applicable</li>
<li>MFnMethods take their original types only, the user must extract the actual MObject or MDagPath explicitly.</li>
<li>MFnMethods do not support undo if it was not explicitly implemented.</li>
<li>MFnMethods are called exactly as stated in the MayaAPI documentation. (Referenced) output parameters are maintained. If the use of MScriptUtil is required, there is usually no way around it unless someone has hand-implemented the method in question.</li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Overloaded signatures are natively available, as you call the actual MFnMethod effectively.</li>
</ol>
</blockquote>
<ol class="arabic" start="7">
<li><p class="first">Docstrings are either the name of the original MFnMethod to help you finding the actual documentation in the default maya api docs, or hand-written documentation on hand-written documentation if it was implemented by hand.</p>
</li>
<li><p class="first">Methods are following the <a href="#id6"><span class="problematic" id="id7">:ref:`'X' and 'setX' &lt;naming-conventions-label&gt;`</span></a> convention, but keep the current MFnMethodNames unaltered.</p>
<div class="system-message" id="id6">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">compare.rst</tt>, line 170); <em><a href="#id7">backlink</a></em></p>
<p>Unknown interpreted text role &quot;ref&quot;.</p>
</div>
</li>
<li><p class="first">MFnMethods are attached to the node type once it is accessed by the first instance. The lookup will only happen once.</p>
</li>
</ol>
</blockquote>
<ol class="arabic simple" start="3">
<li><strong>Plugs/Attributes</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">node.plugname</span></tt> returns an <tt class="docutils literal"><span class="pre">MPlug</span></tt> instance which contains additional methods that have been patched into the 'm' namespace. <a class="footnote-reference" href="#mmnsmrv" id="id8">[4]</a></li>
<li>Plugs can be accessed by their short and long attribute name.</li>
<li>As methods are found first, once a name does not correspond to a method but a plug, this information is stored on the type to make the next plug access less costly for all instances of the given type.</li>
<li>Plugs are not Attributes. Attributes define the type of data and a name for it, Plugs are handles to access the data and to define data flow through connections. MayaAPI semantics are used.</li>
<li><strong>Data Access</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Access primitive data types and strings, all other data types using the <tt class="docutils literal"><span class="pre">MPlug.asMObject</span></tt> and <tt class="docutils literal"><span class="pre">MPlug.masData</span></tt> methods.</li>
<li>Full undo is only implemented for the MRV methods which reside in the 'm' namespace. <a class="footnote-reference" href="#mpmmrv" id="id9">[5]</a></li>
</ol>
</blockquote>
</blockquote>
</dd>
</dl>
</div>
<div class="section" id="node-iteration-node-listing">
<h2>Node Iteration/Node Listing</h2>
<p>This section covers the differences in the interface to retrieve nodes.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first last arabic simple">
<li>Retrieve PyNodes as lists <strong>no iterators ?</strong></li>
<li>Get all DAG nodes using <tt class="docutils literal"><span class="pre">ls(dag=1)</span></tt></li>
<li>Get all DG nodes using <tt class="docutils literal"><span class="pre">ls()</span></tt></li>
<li>List all input or output nodes using <tt class="docutils literal"><span class="pre">node.history</span></tt> and <tt class="docutils literal"><span class="pre">node.future</span></tt>, there no easy way to traverse actual plugs</li>
</ol>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first last arabic simple">
<li>Retrieve iterators yielding Nodes (default), MObjects or MDagPaths</li>
<li>Iterate DAG nodes using <tt class="docutils literal"><span class="pre">iterDagNodes()</span></tt></li>
<li>Iterate all DG nodes using <tt class="docutils literal"><span class="pre">iterDgNodes()</span></tt></li>
<li>Iterate the dependency graph using <tt class="docutils literal"><span class="pre">iterGraph()</span></tt>, or <tt class="docutils literal"><span class="pre">MPlug.miterGraph</span></tt>.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="user-interfaces">
<h2>User Interfaces</h2>
<p>Both frameworks provide wrappers for maya's user interface MEL commands, allowing them to be used in an object oriented fashion.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first arabic simple">
<li><strong>UI Types</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Common base type for all UI elements is <tt class="docutils literal"><span class="pre">PyUI</span></tt>, which is a unicode object.</li>
<li>PyUI instances can be created from the name of maya's UI element. If no name is given, all flags supported by the underlying MEL command can be passed in as keyword argument.</li>
<li>Each UI MEL comamnd has a corresponding capitalized PyUI type</li>
<li>PyUI type hierarchy is solely based on the actual type inheritance in the <tt class="docutils literal"><span class="pre">uitypes</span></tt> module.</li>
<li>PyUI types may inherit from hand-implemented base classes to add custom functionality.</li>
<li>Fully auto-generated UI types derive from PyUI.</li>
</ol>
</blockquote>
<ol class="arabic simple" start="2">
<li><strong>Property Access</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Database information is used to provide <tt class="docutils literal"><span class="pre">getX</span></tt> methods for all long MEL command flags <tt class="docutils literal"><span class="pre">X</span></tt> which can be queried, and <tt class="docutils literal"><span class="pre">setX</span></tt>  methods for all long editable command flags <tt class="docutils literal"><span class="pre">X</span></tt> .</li>
</ol>
<blockquote>
<ul class="simple">
<li>i.e. <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">win.getWidthHeight()</span></tt> or <tt class="docutils literal"><span class="pre">win.setWidthHeight((x,</span> <span class="pre">y))</span></tt> to get and set the dimension of a window.</li>
</ul>
</blockquote>
</blockquote>
<ol class="arabic simple" start="3">
<li><strong>Callback/Event Handling</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li>Callbacks are set using the respective property, usually named <tt class="docutils literal"><span class="pre">setXCommand</span></tt>.</li>
</ol>
<blockquote>
<ul class="simple">
<li>i.e. <tt class="docutils literal"><span class="pre">button.setCommand(stringOrCallable)</span></tt> sets the command to be called once a button is pressed.</li>
</ul>
</blockquote>
<ol class="arabic simple" start="2">
<li>As callbacks correspond to the underlying MEL callback, each one may have zero or one receivers.</li>
<li>Maya callbacks which provide additional arguments return Python types, not just strings like 'true', 'false' or ''.</li>
</ol>
</blockquote>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first arabic">
<li><dl class="first docutils">
<dt><strong>UI Types</strong></dt>
<dd><ol class="first last arabic simple">
<li>Common base type for all UI elements is <tt class="docutils literal"><span class="pre">BaseUI</span></tt>, which is an object. All UI elements with names derive from <tt class="docutils literal"><span class="pre">NamedUI</span></tt>, which is a <tt class="docutils literal"><span class="pre">BaseUI</span></tt>, and a unicode object, among others.</li>
<li>NamedUI instances can be created from the name of maya's UI element. If no name is given, all flags supported by the underlying MEL command can be passed in as keyword argument. BaseUI instances will always instantiate the actual maya UI element ( i.e. modal dialogs ).</li>
<li>Each UI MEL command has a corresponding capitalized BaseUI type</li>
<li>The BaseUI type hierarchy is defined in the database according to the commonalities of the flags of the respective MEL commands.</li>
<li>Types within that hierarchy are hand-implemented to provide common functionality to all derived types. Abstract bases are used as well.</li>
<li>Fully auto-generated UI types derive from their base type as defined in the database.</li>
</ol>
</dd>
</dl>
</li>
<li><p class="first"><strong>Property Access</strong></p>
</li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>A list of short and long property names as manually extracted from the MEL command documentation is kept on the respective UI type, which will be used by the type's metaclass to generate python properties prefixed with <tt class="docutils literal"><span class="pre">p_</span></tt>. The property can be queried, but may not necessarily be edited, which is when a RuntimeError will be produced.</li>
</ol>
<blockquote>
<ul class="simple">
<li>i.e. <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">win.p_wh</span></tt> or <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">win.p_widthHeight</span></tt>, <tt class="docutils literal"><span class="pre">win.p_wh</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">y)</span></tt> or <tt class="docutils literal"><span class="pre">win.p_widthHeight</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">y)</span></tt> to get and set the dimensions of a window.</li>
</ul>
</blockquote>
</blockquote>
<ol class="arabic simple" start="3">
<li><strong>Callback Handling</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li>Callbacks are called Events. A list of short and long event names as manually extracted from the MEL command documentation is kept on the respective UI type, which will be used by the type's metaclass to create UIEvent descriptors prefixed with <tt class="docutils literal"><span class="pre">e_</span></tt>.</li>
</ol>
<blockquote>
<ul class="simple">
<li>i.e. <tt class="docutils literal"><span class="pre">button.e_pressed</span> <span class="pre">=</span> <span class="pre">callable1</span></tt> and <tt class="docutils literal"><span class="pre">button.e_pressed</span> <span class="pre">=</span> <span class="pre">callable2</span></tt> to register two receivers with the button pressed event.</li>
</ul>
</blockquote>
<ol class="arabic simple" start="2">
<li>An event may have any amount of receivers.</li>
<li>Maya callbacks with arguments provide them as strings only. The receiver has to deal with it itself. The first argument of each sent event is the  event's sender.</li>
</ol>
<ul class="simple">
<li>Custom Signals may be created to facilitate QT-like modular user interfaces.</li>
</ul>
</blockquote>
</dd>
</dl>
</div>
<div class="section" id="regression-testing">
<h2>Regression Testing</h2>
<p>Both frameworks feature nose compatible test cases.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first last arabic simple">
<li>Test modules are organized in a flat list of files</li>
<li>Tests can be run in the maya version in your PATH.</li>
<li>There are no utilities to facilitate user interface testing.</li>
</ol>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first last arabic simple">
<li>Test modules are organized in a hierarchy, matching the name and hierarchical location of the modules they test.</li>
<li>Tests can be run easily in all installed maya versions</li>
<li>User interfaces may be tested by the default nose based test system. Maya will be started in minimal GUI mode and runs the specified UI tests.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="interfaces-and-utilities">
<h2>Interfaces and Utilities</h2>
<p>Both frameworks provide additional utilities and interface to handle common problems that arise within maya. The actual implementation varies greatly though, this comparison merely lists the major ones.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first arabic simple">
<li>File handling through procedural interface</li>
<li>Reference handling through custom Type ( <tt class="docutils literal"><span class="pre">FileReference</span></tt> )</li>
<li>Namespace handling through custom Type ( <tt class="docutils literal"><span class="pre">Namespace</span></tt> )</li>
<li>OptionVar handling through custom dict type ( <tt class="docutils literal"><span class="pre">OptionVarDict</span></tt> )</li>
</ol>
<ul class="last simple">
<li><strong>Probably many more</strong></li>
</ul>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first last arabic simple">
<li>File handling though custom Type ( <tt class="docutils literal"><span class="pre">Scene</span></tt> )</li>
<li>Reference handling through custom Type ( <tt class="docutils literal"><span class="pre">FileReference</span></tt> )</li>
<li>Namespace handling through custom Type ( <tt class="docutils literal"><span class="pre">Namespace</span></tt> )</li>
<li>OptionVar handling through custom dict type ( <tt class="docutils literal"><span class="pre">OptionVarDict</span></tt> )</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="standalone-tools">
<h2>Standalone Tools</h2>
<p>Both frameworks offer standalone tools to provide additional functionality. These are listed here by their functionality, including the available platforms.</p>
<dl class="docutils">
<dt><strong>PyMel</strong>:</dt>
<dd><ol class="first arabic simple">
<li><strong>Tools</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>IPython shell with PyMel support, some Maya specific convenience functions like Node name completion and Attribute completion. A dag command lists the scene dag as ascii art. ( <tt class="docutils literal"><span class="pre">ipymel</span></tt>, all platforms )</li>
</ol>
<ul class="simple">
<li>Convert MEL to Python ( <tt class="docutils literal"><span class="pre">mel2py</span></tt>, all platforms )</li>
</ul>
</blockquote>
<ol class="arabic simple" start="2">
<li><strong>Testing</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Run tests in current maya version ( <tt class="docutils literal"><span class="pre">pymel_test</span></tt>, Linux, OSX )</li>
</ol>
</blockquote>
<ol class="arabic simple" start="3">
<li><strong>Maintenance</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li>Compile full documentation  ( <tt class="docutils literal"><span class="pre">make_pymel_docs</span></tt>, linux and osx )</li>
</ol>
<ul class="simple">
<li>Make a new release ( <tt class="docutils literal"><span class="pre">makerelease</span></tt>, linux and OSX )</li>
<li>Rebuild the database caches ( <tt class="docutils literal"><span class="pre">rebuildcaches.py</span></tt>, OSX )</li>
</ul>
</blockquote>
</dd>
<dt><strong>MRV</strong>:</dt>
<dd><ol class="first arabic simple">
<li><strong>Tools</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>IPython shell with MRV support, all MFnFunctions take part in tab completion, but nothing more.</li>
</ol>
<ul class="simple">
<li>Prepare a python standalone interpreter to run MRV and maya ( <tt class="docutils literal"><span class="pre">mrv</span></tt>, All platforms, on windows it uses only the predefined maya version )</li>
</ul>
</blockquote>
<ol class="arabic simple" start="2">
<li><strong>Testing</strong></li>
</ol>
<blockquote>
<ol class="arabic simple">
<li>Run tests in current and specified maya versions ( <tt class="docutils literal"><span class="pre">tmrv</span></tt>, all platforms, on windows the same limitations apply as for <tt class="docutils literal"><span class="pre">mrv</span></tt> )</li>
</ol>
<ul class="simple">
<li>Run UI specific tests in a slimmed down maya UI session, maya executable must be specified ( <tt class="docutils literal"><span class="pre">tmrvUI</span></tt>, all platforms )</li>
<li>Retrieve the test coverage as html report for the specified maya version ( <tt class="docutils literal"><span class="pre">tmrvc</span></tt>, linux and osx )</li>
<li>Full regression testing against all installed maya versions ( <tt class="docutils literal"><span class="pre">tmrvr</span></tt>, linux and osx )</li>
</ul>
</blockquote>
<ol class="arabic simple" start="3">
<li><strong>Maintenance</strong></li>
</ol>
<blockquote class="last">
<ol class="arabic simple">
<li>Compile full documentation ( <tt class="docutils literal"><span class="pre">make</span> <span class="pre">clean</span> <span class="pre">html</span></tt>, Linux and OSX )</li>
</ol>
</blockquote>
</dd>
</dl>
</div>
</div>
<div class="section" id="performance">
<h1>Performance</h1>
<p>Although all performance tests are synthetic and will not give a real indication  of the actual runtime of your scripts, they are able to give a hint about the general performance of certain operations.</p>
<p>The numbers have been produced on a 2Ghz Dual Core Machine running Xubuntu 8.04.  Maya 2010 <a class="footnote-reference" href="#perfm10" id="id10">[6]</a> has been preloaded by the systems virtual memory system, and all temporary  directories are RAM disks (tmpfs).</p>
<p>The tests were run one time only. All MRV performance tests can be found in the  <tt class="docutils literal"><span class="pre">mrv.test.maya.performance</span></tt> module and run using  <tt class="docutils literal"><span class="pre">test/bin/tmrv</span> <span class="pre">[maya_version]</span> <span class="pre">test/maya/performance</span></tt>.</p>
<p>All PyMel tests can be found on the github fork at  <a class="reference external" href="http://github.com/Byron/pymel/tree/performancetests">http://github.com/Byron/pymel/tree/performancetests</a>, and run using  <tt class="docutils literal"><span class="pre">tests/pymel_test.py</span> <span class="pre">tests/performance</span></tt>.</p>
<p>All test cases are presented with their actual code, omitting the code needed to measure the actual time. The final results are presented in a table.</p>
<div class="section" id="mesh-iteration">
<h2>Mesh Iteration</h2>
<p>MRV mesh iteration tests can be found in <tt class="docutils literal"><span class="pre">mrv/test/maya/performance/test_geometry.py</span></tt>.</p>
<p>PyMel mesh iteration tests can be found in <tt class="docutils literal"><span class="pre">pymel/tests/performance/test_geometry.py</span></tt>.</p>
<ul class="simple">
<li><strong>Iter Vtx No-Op</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">The test provides a basis to compute the pure iteration overhead.</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; m = PyNode('mesh40k')
&gt;&gt;&gt; nc = 0
&gt;&gt;&gt; for it in m.vtx:
&gt;&gt;&gt;     nc += 1
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; m = Node('mesh40k')
&gt;&gt;&gt; nc = 0
&gt;&gt;&gt; for it in m.vtx:
&gt;&gt;&gt;     nc += 1
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Iter Vtx Index</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">Iterate vertices and query the index. It show how a very light operation affects iteration performance</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.vtx:
&gt;&gt;&gt;     it.index()
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.vtx:
&gt;&gt;&gt;     it.getIndex()
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Iter Vtx Position</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">Iterate vertices and query their local space position. This operation is more costly due to the potential space transformation.</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.vtx:
&gt;&gt;&gt;     it.getPosition()
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.vtx:
&gt;&gt;&gt;     it.position()
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Iter Edge Position</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">Iterate edges and query their vertice's positions in local space</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.e:
&gt;&gt;&gt;     it.getPoint(0)
&gt;&gt;&gt;     it.getPoint(1)
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.e:
&gt;&gt;&gt;     it.point(0)
&gt;&gt;&gt;     it.point(1)
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Iter Poly Position</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">Iterate polygons and query all the polygon's vertex positions in localspace</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for it in m.f:
&gt;&gt;&gt;     it.getVertices()
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; ia = api.MIntArray()
&gt;&gt;&gt; for it in m.f:
&gt;&gt;&gt;     it.getVertices(ia)
</pre>
</li>
</ul>
</blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="36%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Test</th>
<th class="head">PyMel 1.0.1</th>
<th class="head">MRV 1.0.0 Preview</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Iter Vtx No-Op</td>
<td>4,96s ( 8.018 vtx/s )</td>
<td>0,019s ( 2.009.699 vtx/s )</td>
</tr>
<tr><td>Iter Vtx Index</td>
<td>4,95s ( 8.035 vtx/s )</td>
<td>0,037s ( 1.065.929 vtx/s )</td>
</tr>
<tr><td>Iter Vtx Position</td>
<td>23,69s ( 1.679 vtx/s )</td>
<td>0,070s ( 565.626 vtx/s )</td>
</tr>
<tr><td>Iter Edge Position</td>
<td>59,82s ( 665 e/s )</td>
<td>0,329s ( 120.621 e/s )</td>
</tr>
<tr><td>Iter Poly Position</td>
<td>13,36s ( 2.977 f/s )</td>
<td>0,065s ( 609.627 f/s )</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="set-vertex-colors">
<h2>Set Vertex Colors</h2>
<p>This more complex example performs an actual computation. It will set the verex color relative to the average length of the edges connected to the vertex in question.</p>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; obj = PyNode('mesh40k')

&gt;&gt;&gt; cset = 'edgeLength'
&gt;&gt;&gt; obj.createColorSet(cset)
&gt;&gt;&gt; obj.setCurrentColorSetName(cset)
&gt;&gt;&gt; colors = []
&gt;&gt;&gt; el = api.MIntArray()
&gt;&gt;&gt; el.setLength(obj.numVertices())
&gt;&gt;&gt; maxLen = 0.0
&gt;&gt;&gt; for vid, vtx in enumerate(obj.vtx):
&gt;&gt;&gt;     edgs = vtx.connectedEdges()
&gt;&gt;&gt;     totalLen=0
&gt;&gt;&gt;     for edg in edgs:
&gt;&gt;&gt;             totalLen += edg.getLength()
&gt;&gt;&gt;
&gt;&gt;&gt;     avgLen=totalLen / len(edgs)
&gt;&gt;&gt;     maxLen = max(avgLen, maxLen)
&gt;&gt;&gt;     el[vid] = avgLen
&gt;&gt;&gt;     colors.append(Color.black)
&gt;&gt;&gt;
&gt;&gt;&gt; for vid, col in enumerate(colors):
&gt;&gt;&gt;     col.b = el[vid] / maxLen
&gt;&gt;&gt;
&gt;&gt;&gt; obj.setColors( colors )
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; cset = 'edgeLength'
&gt;&gt;&gt; m = Node('mesh40k')
&gt;&gt;&gt;
&gt;&gt;&gt; m.createColorSetWithName(cset)
&gt;&gt;&gt; m.setCurrentColorSetName(cset)
&gt;&gt;&gt;
&gt;&gt;&gt; lp = api.MPointArray()
&gt;&gt;&gt; m.getPoints(lp)
&gt;&gt;&gt;
&gt;&gt;&gt; colors = api.MColorArray()
&gt;&gt;&gt; colors.setLength(m.numVertices())
&gt;&gt;&gt;
&gt;&gt;&gt; vids = api.MIntArray()
&gt;&gt;&gt; vids.setLength(len(colors))
&gt;&gt;&gt;
&gt;&gt;&gt; el = api.MFloatArray()
&gt;&gt;&gt; el.setLength(len(colors))
&gt;&gt;&gt; cvids = api.MIntArray()
&gt;&gt;&gt;
&gt;&gt;&gt; # compute average edge-lengths
&gt;&gt;&gt; max_len = 0.0
&gt;&gt;&gt; for vid, vit in enumerate(m.vtx):
&gt;&gt;&gt;     vit.getConnectedVertices(cvids)
&gt;&gt;&gt;     cvp = lp[vid]
&gt;&gt;&gt;     accum_edge_len=0.0
&gt;&gt;&gt;     for cvid in cvids:
&gt;&gt;&gt;             accum_edge_len += (lp[cvid] - cvp).length()
&gt;&gt;&gt;     avg_len = accum_edge_len / len(cvids)
&gt;&gt;&gt;     max_len = max(avg_len, max_len)
&gt;&gt;&gt;     el[vid] = avg_len
&gt;&gt;&gt;     vids[vid] = vid
&gt;&gt;&gt;
&gt;&gt;&gt; for cid in xrange(len(colors)):
&gt;&gt;&gt;     c = colors[cid]
&gt;&gt;&gt;     c.b = el[cid] / max_len
&gt;&gt;&gt;     colors[cid] = c
&gt;&gt;&gt;
&gt;&gt;&gt; m.setVertexColors(colors, vids, api.MDGModifier())
</pre>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="37%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Test</th>
<th class="head">PyMel 1.0.1</th>
<th class="head">MRV 1.0.0 Preview</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Set Vertex Colors</td>
<td>153,07s ( 259 colors/s )</td>
<td>1,715s ( 23.198 colors/s )</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="node-wrapping">
<h2>Node Wrapping</h2>
<p>Both frameworks rely on custom types which wrap the underlying API object to provide a more convenient programming interface. The process of wrapping an API object in an instance of a custom type can be costly, and as both frameworks return these by default, node wrapping performance directly affects the performance of all operations.</p>
<p>The scene loaded for the test contains more than 2500 DAG and DG nodes which are to be wrapped.</p>
<p>As preparation, strings of all nodes in the scene are stored in the node_strings list. All (Py)Nodes are stored for later extraction of the API objects.</p>
<ul class="simple">
<li><strong>Wrap from String</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for name in nodes_strings:
&gt;&gt;&gt;     PyNode(name)
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for name in nodenames:
&gt;&gt;&gt;     Node( name )
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Wrap from String2</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">MRV supports a fast constructor which can be used to construct Node instances from strings only. There is no equivalent in PyMel</p>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for name in nodenames:
&gt;&gt;&gt;     tmplist.append(NodeFromStr(name))
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Wrap from API Obj</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for apiobj in nodes_apiobjects:
&gt;&gt;&gt;     PyNode(apiobj)
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for apiobj in nodes_apiobjects:
&gt;&gt;&gt;     Node(apiobj)
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Wrap from API Obj2</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">MRV supports fast constructors which get right to the point, and are more specialized. There is no equivalent in PyMel</p>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for apiobj in nodes_apiobjects:
&gt;&gt;&gt;     NodeFromObj(apiobj)
</pre>
</li>
</ul>
</blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="35%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Test</th>
<th class="head">PyMel 1.0.1</th>
<th class="head">MRV 1.0.0 Preview</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Wrap from String</td>
<td>1,84s ( 5.928 Nodes/s )</td>
<td>0,469s ( 15.553 nodes/s )</td>
</tr>
<tr><td>Wrap from String2</td>
<td>xxxxxxxxxxxxxxxxxxxxxxx</td>
<td>0,426s ( 17.539 nodes/s )</td>
</tr>
<tr><td>Wrap from API Obj</td>
<td>0,727s ( 15.068 nodes/s)</td>
<td>0,112s ( 67.264 nodes/s )</td>
</tr>
<tr><td>Wrap from API Obj2</td>
<td>xxxxxxxxxxxxxxxx</td>
<td>0,079s ( 94.665 nodes/s )</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="node-handling">
<h2>Node Handling</h2>
<p>Nodes can be created, renamed, and their DAG relationships may change through parenting and instancing.</p>
<p>The following test creates 1000 dg nodes ( <tt class="docutils literal"><span class="pre">network</span></tt> ) as well as 1000 dag nodes ( <tt class="docutils literal"><span class="pre">transform</span></tt> ) and renames them afterwards. The code shown here is only comprised of the lines which are of actual importance, some boilerplate code is omitted.</p>
<ul class="simple">
<li><strong>Create DG Nodes</strong> and <strong>Create DAG Nodes</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for node_type in ('network', 'transform'):
&gt;&gt;&gt;     for number in xrange(nn):
&gt;&gt;&gt;             createNode(node_type)
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for node_type in ('network', 'transform'):
&gt;&gt;&gt;     for number in xrange(nn):
&gt;&gt;&gt;             createNode(node_type, node_type)
</pre>
</li>
</ul>
</blockquote>
<ul>
<li><p class="first"><strong>Rename DG Nodes</strong> and ** Rename DAG Nodes**</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for node in nodes:
&gt;&gt;&gt;     node.rename(node.name()[:-1])
</pre>
</li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for node in node_list:
&gt;&gt;&gt;     node.rename(node.basename()[:-1])
</pre>
</li>
</ul>
</blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="38%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Test</th>
<th class="head">PyMel 1.0.1</th>
<th class="head">MRV 1.0.0 Preview</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Create DG Nodes</td>
<td>0,456s ( 2.190 Nodes/s )</td>
<td>0,436s ( 2.290 nodes/s )</td>
</tr>
<tr><td>Create DAG Nodes</td>
<td>0,425s ( 2.348 Nodes/s )</td>
<td>0,504s ( 1.983 nodes/s )</td>
</tr>
<tr><td>Rename DG Nodes</td>
<td>0,553s ( 1.807 Nodes/s )</td>
<td>0,290s ( 3.437 nodes/s )</td>
</tr>
<tr><td>Rename DAG Nodes</td>
<td>0,465s ( 2.148 Nodes/s )</td>
<td>0,339s ( 2.941 nodes/s )</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="attributes-and-plugs">
<h2>Attributes and Plugs</h2>
<p>Whether you want to access data, or make new connections to alter the data flow, MPlugs (MRV) and Attributes (PyMel) are required to do it.</p>
<p>The following tests take part in a scene with more than 21000 animation nodes and plenty of corresponding animated DAG and DG nodes of different types. The animation nodes are first retrieved, then their output plugs are accessed.</p>
<ul class="simple">
<li><strong>Get Anim Nodes</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; anim_nodes = ls(type=&quot;animCurve&quot;)
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; anim_nodes = list(iterDgNodes(Node.Type.kAnimCurve))
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Access Plug/Attr</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for anode in anim_nodes:
&gt;&gt;&gt;     anode.output
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for anode in anim_nodes:
&gt;&gt;&gt;     anode.output
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Access Plug</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">In MRV, one can access the plug using an MFn method. In PyMel, its not possible to receive the plug</p>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for anode in anim_nodes:
&gt;&gt;&gt;     anode.findPlug('output')
</pre>
</li>
</ul>
</blockquote>
<p>The following tests are to determine the performance of the retrieval of simple floating point data, using the plug/attribute as well as an MFnMethod.</p>
<p>The variable <tt class="docutils literal"><span class="pre">p</span></tt> is a PyNode/Node of the perspective camera ( shape ). The loop is set to 50000 iterations.</p>
<ul class="simple">
<li><strong>Access Plug/Attr 2</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">Access the same plug/attribute repeatedly on the same node</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.fl
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.fl
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Get Plug/Attr Data</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.fl.get()
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.fl.asFloat()
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>MFnMethod Access</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.getFocalLength
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.focalLength
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>MFnMethod Call</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.getFocalLength()
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for iteration in xrange(na):
&gt;&gt;&gt;     p.focalLength()
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Plug/Attr Connection</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">The test contains two network nodes which feature multi-message plugs/attributes. 5000 of these are connected with each other, from one network node to another. A utility is used to produce the required element plugs/attributes.</p>
</li>
<li><p class="first">Please note that single connecting plugs is inefficient, in case of MRV its better to use <tt class="docutils literal"><span class="pre">MPlug.mconnectMultiToMulti</span></tt> to get 10x the performance.</p>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for source, dest in zip(pir(sn.a, r), pir(tn.ab, r)):
&gt;&gt;&gt;     source &gt; dest
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for source, dest in zip(pir(sn.a, r), pir(tn.ab, r)):
&gt;&gt;&gt;     source.mconnectTo(dest)
</pre>
</li>
</ul>
</blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="35%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Test</th>
<th class="head">PyMel 1.0.1</th>
<th class="head">MRV 1.0.0 Preview</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Get Anim Nodes</td>
<td>10,26s ( 2.086 nodes/s )</td>
<td>0,393s ( 54.357 nodes/s )</td>
</tr>
<tr><td>Access Plug/Attr</td>
<td>3,99s ( 5.363 attrs/s )</td>
<td>0,309s ( 69.872 plugs/s )</td>
</tr>
<tr><td>Access Plug</td>
<td>xxxxxxxxxxxxxxxxxxxxxxx</td>
<td>0,275s ( 77.771 plugs/s )</td>
</tr>
<tr><td>Access Plug/Attr 2</td>
<td>6,51s ( 7.671 attrs/s )</td>
<td>0,718s ( 69.579 plugs/s )</td>
</tr>
<tr><td>Get Plug/Attr Data</td>
<td>14,04 ( 3.559 values/s )</td>
<td>1,03s ( 48.483 values/s )</td>
</tr>
<tr><td>MFnMethod Access</td>
<td>0,0079s( 6.260.342 accesses/s )</td>
<td>0,0061s ( 8.184.646 accesses/s )</td>
</tr>
<tr><td>MFnMethod Call</td>
<td>0,470s ( 106.234 calls/s )</td>
<td>0,286 ( 174.749 calls/s )</td>
</tr>
<tr><td>Plug/Attr Connection</td>
<td>1,35s ( 3698 connections/s )</td>
<td>1,072 ( 4662 connections/s )</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="startup-time-and-memory-consumption">
<h2>Startup Time and Memory Consumption</h2>
<p>When using a framework, it should ideally unfold its capabilities as fast as possible thanks to minimal loading times, and be as small as possible in main memory to keep more available for the actual task.</p>
<p>This test regards two different scenarios: Usage in the script editor in gui mode and usage as part of a program running in a standalone python interpreter. The version running in the script editor should have all functionality available in the root namespace and imports everything, whereas the program will only import core functionality.</p>
<p>In Gui mode, the time actually measured is the time it takes to import the respective modules from a freshly started maya with no plugins loaded.</p>
<p>In standalone mode, the time it takes to startup the interpreter and import the core framework modules is measured - they are assumed to initialize maya standalone. In MRV, undo is enabled even in standalone mode to be more comparable to PyMel which doesn't allow that. In MRVs case, the time and memory it takes to load a plugin could be saved otherwise.</p>
<p>The memory consumption is measure by checking the resident memory of the program before and after the import of the respective modules.</p>
<p>All GUI tests are performed in Maya 2011 on OSX - I could not activate my trial on linux. The OSX machine is a 2ghz dual core with 4GB of RAM.
All standalone tests are performed on Maya 2011 on Xubuntu linux as it nicely shows how fast maya can be startup.</p>
<p>All tests have been performed at least two times, the best time was used.</p>
<ul class="simple">
<li><strong>GUI Import Time</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from pymel.all import *
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mrv.maya.all import *
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>OpenMaya Memory/Time</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">As both frameworks use OpenMaya and import all modules, the memory it takes to do so as well as the time it takes to load is included in the measurements:</p>
<pre class="literal-block">
&gt;&gt;&gt; import maya.OpenMaya
&gt;&gt;&gt; import maya.OpenMayaMPx
&gt;&gt;&gt; import maya.OpenMayaRender
&gt;&gt;&gt; import maya.OpenMayaFX
&gt;&gt;&gt; import maya.OpenMayaAnim
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>GUI Memory</strong></li>
</ul>
<blockquote>
<ul class="simple">
<li>The memory was measured once before importing the modules using the code above, and once after the import.</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Standalone Startup</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
$ time mrv 2011 -c &quot;import pymel.core&quot;
</pre>
</li>
<li><p class="first">Please note that the line above always crashed while deflating the database using zip ( for some strange reason ), so I had to use another line which worked:</p>
<pre class="literal-block">
$ time mrv 2011 -c &quot;import pymel.all&quot;
</pre>
</li>
<li><p class="first">The line above did not terminate maya correctly, but it was at least started up so a time could be extracted.</p>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
$ time mrv 2011 -c &quot;import mrv.maya.nt&quot;
</pre>
</li>
</ul>
</blockquote>
<ul class="simple">
<li><strong>Standalone Memory</strong></li>
</ul>
<blockquote>
<ul>
<li><p class="first">The memory is measured in a python interactive shell due to its persistent nature. The base memory is measured after manually initializing maya standalone. Afterwards, the respective core modules are imported:</p>
<pre class="literal-block">
&gt;&gt;&gt; import maya.standalone
&gt;&gt;&gt; maya.standalone.initialize()
</pre>
</li>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; import pymel.core
</pre>
</li>
<li><p class="first">Please note that the above line would crash at the same spot as it did during the startup test, so the following line worked so far:</p>
<pre class="literal-block">
&gt;&gt;&gt; import pymel.all
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; import mrv.maya.nt
</pre>
</li>
</ul>
</blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="41%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Test</th>
<th class="head">PyMel 1.0.1</th>
<th class="head">MRV 1.0.0 Preview</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>OpenMaya Memory/Time</td>
<td>203,5 MB -&gt; 215,7 MB == 12,2 MB in 0,22s</td>
<td>see left side</td>
</tr>
<tr><td>GUI Import Time</td>
<td>2,37s</td>
<td>0.62s</td>
</tr>
<tr><td>GUI Memory</td>
<td>203,5 MB -&gt; 291,1 MB == 87,6 MB</td>
<td>203,5 MB -&gt; 224,5 MB == 21,0 MB</td>
</tr>
<tr><td>Standalone  Startup</td>
<td>8,24s (<em>invalid run due to repeatable crash</em>)</td>
<td>5,74s</td>
</tr>
<tr><td>Standalone Memory</td>
<td>123,7 MB -&gt; 253,9 MB == 130,2 MB (<em>invalid run</em>)</td>
<td>123,7 MB -&gt; 153,1 MB == 29,4 MB</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">During testing, it is recommended to use maya 8.5 or 2008 as they will be ready in 3,2s (8.5) to 3,8s (2008).</p>
</div>
</div>
</div>
<div class="section" id="usage-examples">
<h1>Usage Examples</h1>
<p>The listing concentrates on the code required to perform everyday and  simple tasks. It assumes that all required classes and functions have been  imported into the module where the code is run. This is done most easily using <tt class="docutils literal"><span class="pre">from</span> <span class="pre">pymel.all</span> <span class="pre">import</span> <span class="pre">*</span></tt> (<tt class="docutils literal"><span class="pre">PyMel</span></tt>) or <tt class="docutils literal"><span class="pre">from</span> <span class="pre">mrv.maya.all</span> <span class="pre">import</span> <span class="pre">*</span></tt> (<tt class="docutils literal"><span class="pre">MRV</span></tt>).</p>
<p>As a general difference you will notice that PyMel is very convenient to use through a variety of smart methods which handle many details behind the scenes.</p>
<p>MRV is derived from the MayaAPI, and uses its interface. Compared to MayaAPI code, its like a short hand writing style, yet it remains verbose compared to PyMel and very explicit.</p>
<div class="section" id="set-handling">
<h2>Set Handling</h2>
<p>Sets are a very nice feature in Maya, as well as their implementation. Handling of sets should be easy and intuitive in the framework you use.</p>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; p, t, f = PyNode('persp'), PyNode('top'), PyNode('front')
&gt;&gt;&gt; s = sets()

&gt;&gt;&gt; # add single
&gt;&gt;&gt; s.add(p)
&gt;&gt;&gt; assert p in s

&gt;&gt;&gt; # add multiple - need sets command for undo support
&gt;&gt;&gt; sets(s, add=(t,f))
&gt;&gt;&gt; # same in MEL, argument meaning changed in PyMel
&gt;&gt;&gt; cmds.sets(str(t), str(f), add=str(s))

&gt;&gt;&gt; # remove single
&gt;&gt;&gt; s.remove(p)

&gt;&gt;&gt; # remove multiple
&gt;&gt;&gt; sets(s, rm=(t,f))
&gt;&gt;&gt; assert sets(s, q=1, size=1) == 0
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; p, t, f = Node('persp'), Node('top'), Node('front')
&gt;&gt;&gt; s = ObjectSet()

&gt;&gt;&gt; # add single - set centric or object centric
&gt;&gt;&gt; s.add(p)
&gt;&gt;&gt; p.addTo(s)
&gt;&gt;&gt; assert p in s

&gt;&gt;&gt; # add multiple
&gt;&gt;&gt; s.add((t, f))

&gt;&gt;&gt; # remove single - set or object centric
&gt;&gt;&gt; s.discard(p)
&gt;&gt;&gt; p.removeFrom(s)

&gt;&gt;&gt; # remove multiple
&gt;&gt;&gt; s.discard((t, f))

&gt;&gt;&gt; assert len(s) == 0
</pre>
</li>
</ul>
</div>
<div class="section" id="shading-engine-handling">
<h2>Shading Engine Handling</h2>
<p>ShadingEngines are ObjectSets, but are specialized for the purpose of rendering. The renderPartition assures that one object or face is only handled by exactly one shading engine.</p>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; isg = PyNode(&quot;initialShadingGroup&quot;)
&gt;&gt;&gt; rp = PyNode(&quot;renderPartition&quot;)

&gt;&gt;&gt; # assign new shading engine to the render partition
&gt;&gt;&gt; sg = createNode('shadingEngine')
&gt;&gt;&gt; rp.sets.evaluateNumElements()

&gt;&gt;&gt; # the partition plug is overridden by the 'partition' function of the
&gt;&gt;&gt; # underlying pseudostring
&gt;&gt;&gt; # sg.partition &gt; rp.sets[rp.sets.getNumElements()]
&gt;&gt;&gt; sg.pa &gt; rp.sets[rp.sets.getNumElements()]

&gt;&gt;&gt; m = polySphere()[0].getShape()

&gt;&gt;&gt; # assign all faces to the initial shading group
&gt;&gt;&gt; # m is automatically part of the default shading engine
&gt;&gt;&gt; isg.remove(m)
&gt;&gt;&gt; isg.add(m.f)

&gt;&gt;&gt; # assign 200 faces to another shading group
&gt;&gt;&gt; # Cannot use object as it does not allow to force the membersship
&gt;&gt;&gt; # sg.add(m.f[0:199])
&gt;&gt;&gt; sets(sg, fe=m.f[0:199])
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; # NOTE: this test is part of the pymel comparison
&gt;&gt;&gt; isg = Node(&quot;initialShadingGroup&quot;)
&gt;&gt;&gt; rp = Node(&quot;renderPartition&quot;)

&gt;&gt;&gt; # assign new shading engine to the render partition
&gt;&gt;&gt; sg = ShadingEngine()
&gt;&gt;&gt; sg.setPartition(rp)


&gt;&gt;&gt; # create a poly sphere
&gt;&gt;&gt; m = Mesh()
&gt;&gt;&gt; PolySphere().output.mconnectTo(m.inMesh)

&gt;&gt;&gt; # assign all faces to the initial shading group
&gt;&gt;&gt; # Cannot use the m.cf[:] shortcut to get a complete component as
&gt;&gt;&gt; # shading engines apparently don't deal with it properly
&gt;&gt;&gt; m.addTo(isg, m.cf[:m.numPolygons()])

&gt;&gt;&gt; # force the first 200 faces into another shading engine
&gt;&gt;&gt; m.addTo(sg, m.cf[:200], force=True)
</pre>
</li>
</ul>
</div>
<div class="section" id="mixed">
<h2>Mixed</h2>
<p>The following example was taken from the PyMel homepage at <a class="reference external" href="http://code.google.com/p/pymel/">http://code.google.com/p/pymel/</a> as it goes through a few general tasks.</p>
<ul>
<li><p class="first"><strong>PyMel</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for x in ls( type='transform'):
&gt;&gt;&gt;     print x.longName()                # object oriented design
&gt;&gt;&gt;
&gt;&gt;&gt;     x.sx &gt;&gt; x.sy                      # connection operator
&gt;&gt;&gt;     x.sx &gt;&gt; x.sz
&gt;&gt;&gt;     x.sx // x.sy                      # disconnection operator
&gt;&gt;&gt;     x.sx.disconnect()                 # smarter methods -- (automatically disconnects all inputs and outputs when no arg is passed)

&gt;&gt;&gt; # add and set a string array attribute with the history of this transform's shape
&gt;&gt;&gt;     x.setAttr( 'newAt', x.getShape().history(), force=1 )

&gt;&gt;&gt;     # get and set some attributes
&gt;&gt;&gt;     x.rotate.set( [1,1,1] )
&gt;&gt;&gt;     trans = x.translate.get()
&gt;&gt;&gt;     trans *= x.scale.get()           # vector math
&gt;&gt;&gt;     x.translate.set( trans )         # ability to pass list/vector args
&gt;&gt;&gt;     # mel.myMelScript(x.type(), trans) # automatic handling of mel procedures
</pre>
</li>
<li><p class="first"><strong>MRV</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; import mrv.maya as mrvmaya                  # required for some utilities
&gt;&gt;&gt; # later we query the shape, hence we must assure we actually have one
&gt;&gt;&gt; # and setup a custom predicate
&gt;&gt;&gt; for x in iterDagNodes(Node.Type.kTransform, predicate=lambda n: n.childCount()):
&gt;&gt;&gt;     print x.name()                          # name() always returns the full path name
&gt;&gt;&gt;
&gt;&gt;&gt;     x.sx.mconnectTo(x.sy)                   # Convenience methods are located in the 'm' namespace of the MPlug type
&gt;&gt;&gt;     x.sx.mconnectTo(x.sz)
&gt;&gt;&gt;     x.sx.mdisconnectFrom(x.sy)
&gt;&gt;&gt;     x.sx.mdisconnect()
&gt;&gt;&gt;
&gt;&gt;&gt;     default = StringArrayData.create(list())
&gt;&gt;&gt;     shapehistory = [n.name() for n in iterGraph(x[0], input=True)]
&gt;&gt;&gt;     x.addAttribute(TypedAttribute.create('newAt', 'na', Data.Type.kStringArray, default)).masData().set(shapehistory)
&gt;&gt;&gt;
&gt;&gt;&gt;     x.rx.msetFloat(1.0)                     # using individual plugs to have undo support, otherwise you would use MFn methods, like setRotation(...)
&gt;&gt;&gt;     x.ry.msetFloat(1.0)
&gt;&gt;&gt;     x.rz.msetFloat(1.0)

&gt;&gt;&gt;     trans = x.getTranslation(api.MSpace.kTransform)
&gt;&gt;&gt;     dot = trans * x.getScale()                   # the dot product is a single float, MVector has no in-place dot-product as the type changes
&gt;&gt;&gt;     x.tx.msetFloat(dot)                   # have to use child plugs for undo support
&gt;&gt;&gt;     x.ty.msetFloat(dot)
&gt;&gt;&gt;     x.tz.msetFloat(dot)

&gt;&gt;&gt;     # mrvmaya.Mel.myScript(x.typeName(), trans) # its essentially the pymel implementation which is used here.
</pre>
</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="mv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Whether a method can be called through a Node or not</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="moppymel" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>MFnCamera.getFilmFrustrum( double distance, MPointArray clipPlanes ) can be called like Camera.getFilmFrustrum( 10.0 ), returning a tuple of 4</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mapymel" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td><tt class="docutils literal"><span class="pre">MFnDagNode::child</span></tt> becomes <tt class="docutils literal"><span class="pre">DagNode.childAtIndex</span></tt>, and is not available under <tt class="docutils literal"><span class="pre">DagNode.child</span></tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mmnsmrv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td>All patches applied to globally available MayaAPI types, such as MPlug or MSelection list reside in the 'm' namespace to prevent clashes with possibly existing patched methods.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mpmmrv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>This is potentially dangerous as <tt class="docutils literal"><span class="pre">MPlug.msetFloat(...)</span></tt> supports undo, whereas the original MPlug.setFloat(...) does not. There is a debugging environment variable which helps to find these kind of bugs.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="perfm10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[6]</a></td><td>Maya 2010 is the fastest release so far regarding the python performance. Maya 2011 is about 7% slower.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
